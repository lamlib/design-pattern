<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGV 3D Monitor</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; background: #1e1e1e; color: #d4d4d4; }
        .app { display: flex; height: 100vh; }
        .sidebar {
            width: 300px;
            min-width: 260px;
            background: #252526;
            border-right: 1px solid #3c3c3c;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .sidebar-header {
            padding: 16px;
            background: #2d2d30;
            border-bottom: 1px solid #3c3c3c;
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }
        .sidebar-content { flex: 1; overflow-y: auto; padding: 8px 0; }
        .panel {
            border-bottom: 1px solid #3c3c3c;
        }
        .panel-header {
            padding: 10px 14px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            background: #2d2d30;
            color: #ccc;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .panel-header:hover { background: #3c3c3c; color: #fff; }
        .panel-header::after { content: '▼'; font-size: 10px; opacity: 0.7; }
        .panel.open .panel-header::after { content: '▲'; }
        .panel-body { padding: 10px 14px; background: #252526; display: none; }
        .panel.open .panel-body { display: block; }
        .form-row { margin-bottom: 10px; }
        .form-row:last-child { margin-bottom: 0; }
        .form-label { display: block; font-size: 11px; color: #9d9d9d; margin-bottom: 4px; }
        .form-label + select,
        .form-label + input[type="range"] { width: 100%; }
        select {
            width: 100%;
            padding: 6px 8px;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            
            font-size: 12px;
        }
        select:focus { outline: none; border-color: #007acc; }
        .btn {
            display: inline-block;
            padding: 6px 12px;
            margin: 2px 4px 2px 0;
            background: #0e639c;
            color: #fff;
            border: none;
            
            font-size: 12px;
            cursor: pointer;
        }
        .btn:hover { background: #1177bb; }
        .btn-secondary { background: #3c3c3c; }
        .btn-secondary:hover { background: #505050; }
        .btn-danger { background: #c5282c; }
        .btn-danger:hover { background: #e03e42; }
        .btn-success { background: #16825d; }
        .btn-success:hover { background: #1a9d6b; }
        .checkbox-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .checkbox-row input[type="checkbox"] { width: 16px; height: 16px; accent-color: #0e639c; cursor: pointer; }
        .main { flex: 1; position: relative; min-width: 0; }
        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 4px 12px;
            background: rgba(0,0,0,0.6);
            font-size: 11px;
            color: #9d9d9d;
            display: flex;
            gap: 16px;
        }
        .agv-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            
            font-size: 11px;
            pointer-events: none;
            white-space: nowrap;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="app">
        <aside class="sidebar">
            <div class="sidebar-header">AGV 3D Studio</div>
            <div class="sidebar-content" id="sidebarContent"></div>
        </aside>
        <main class="main">
            <div id="container"></div>
            <div class="status-bar">
                <span>AGV: <strong id="activeCount">0</strong></span>
                <span id="statusPath">Path: 0</span>
                <span id="statusFloor">Tầng: 1</span>
            </div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    
    <script>
        // Kiểm tra loaders đã được load chưa
        function checkLoaders() {
            const loaders = {
                GLTFLoader: typeof THREE !== 'undefined' && typeof THREE.GLTFLoader !== 'undefined',
                OBJLoader: typeof THREE !== 'undefined' && typeof THREE.OBJLoader !== 'undefined',
                FBXLoader: typeof THREE !== 'undefined' && typeof THREE.FBXLoader !== 'undefined'
            };
            
            if (!loaders.GLTFLoader) {
                console.warn('GLTFLoader chưa được load. Import GLTF/GLB sẽ không hoạt động.');
            }
            if (!loaders.OBJLoader) {
                console.warn('OBJLoader chưa được load. Import OBJ sẽ không hoạt động.');
            }
            if (!loaders.FBXLoader) {
                console.warn('FBXLoader chưa được load. Import FBX sẽ không hoạt động.');
            }
            
            return loaders;
        }
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.Fog(0x1a1a1a, 100, 500);
        
        // Kiểm tra loaders sau khi Three.js đã load
        setTimeout(() => {
            checkLoaders();
        }, 1000);

        // Kích thước vùng 3D (dùng cho camera aspect, tránh bị cắt khi có sidebar)
        function getViewSize() {
            const el = document.querySelector('.main') || document.getElementById('container');
            return el ? { w: el.clientWidth || window.innerWidth, h: el.clientHeight || window.innerHeight } : { w: window.innerWidth, h: window.innerHeight };
        }
        const viewSizePx = getViewSize();
        const aspect = viewSizePx.w / Math.max(1, viewSizePx.h);
        const viewSize = 100;
        
        // OrthographicCamera (aspect theo vùng 3D, không dùng toàn màn hình)
        const orthographicCamera = new THREE.OrthographicCamera(
            -viewSize * aspect,
            viewSize * aspect,
            viewSize,
            -viewSize,
            0.1,
            1000
        );
        orthographicCamera.position.set(50, 50, 50);
        orthographicCamera.lookAt(0, 0, 0);
        
        // PerspectiveCamera
        const perspectiveCamera = new THREE.PerspectiveCamera(
            60,
            aspect,
            0.1,
            1000
        );
        perspectiveCamera.position.set(50, 50, 50);
        perspectiveCamera.lookAt(0, 0, 0);
        
        // Camera hiện tại (mặc định là Orthographic)
        let camera = orthographicCamera;
        let isOrthographic = true;

        // Renderer (kích thước theo vùng 3D .main khi dùng layout desktop)
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const initialSize = getViewSize();
        renderer.setSize(initialSize.w, initialSize.h);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        // Raycaster + mouse (dùng cho click/chọn khối và control point)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        function setMouseFromEvent(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        // Chỉ chạy khi đang tạo path — không ảnh hưởng hành vi chọn/kéo khối khi không tạo path
        let _onControlPointMouseDown = null;
        renderer.domElement.addEventListener('mousedown', function (e) {
            if (isCreatingPath && _onControlPointMouseDown) _onControlPointMouseDown(e);
        }, true);
        renderer.domElement.addEventListener('pointerdown', function (e) {
            if (isCreatingPath && _onControlPointMouseDown) _onControlPointMouseDown(e);
        }, true);

        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 200;
        controls.target.set(0, 0, 0);
        
        // Hàm chuyển đổi giữa Orthographic và Perspective camera
        function toggleCamera() {
            // Lưu vị trí và target hiện tại
            const currentPosition = camera.position.clone();
            const currentTarget = controls.target.clone();
            const currentZoom = controls.getDistance ? controls.getDistance() : 50;
            
            // Chuyển đổi camera
            isOrthographic = !isOrthographic;
            
            if (isOrthographic) {
                camera = orthographicCamera;
                const vs = getViewSize();
                const aspect = vs.w / Math.max(1, vs.h);
                const viewSize = currentZoom * 0.5;
                orthographicCamera.left = -viewSize * aspect;
                orthographicCamera.right = viewSize * aspect;
                orthographicCamera.top = viewSize;
                orthographicCamera.bottom = -viewSize;
                orthographicCamera.updateProjectionMatrix();
            } else {
                camera = perspectiveCamera;
                const vs = getViewSize();
                perspectiveCamera.aspect = vs.w / Math.max(1, vs.h);
                perspectiveCamera.updateProjectionMatrix();
            }
            
            // Khôi phục vị trí và target
            camera.position.copy(currentPosition);
            controls.target.copy(currentTarget);
            
            // Cập nhật controls với camera mới
            controls.dispose();
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 200;
            controls.target.copy(currentTarget);
            controls.update();
            
            // Cập nhật TransformControls với camera mới
            if (transformControls) {
                transformControls.setCamera(camera);
            }
            
            // Cập nhật config
            if (typeof config !== 'undefined') {
                config.cameraType = isOrthographic ? 'Orthographic' : 'Perspective';
            }
        }
        
        // Hệ thống quản lý khối trên map
        const blocks = []; // Mảng lưu các khối
        let selectedBlock = null; // Khối đang được chọn
        let selectedAGV = null; // AGV đang được chọn
        let transformControls = null; // TransformControls để điều khiển khối
        
        // Object để hiển thị thông tin AGV trong dat.GUI
        let agvInfo = {
            selectedAGVId: 'Chưa chọn AGV',
            hasImportedModel: false
        };
        
        // Khởi tạo TransformControls
        // Hàm helper để tìm điểm gần nhất trên curve
        function findNearestPointOnCurve(curve, targetPoint, samples = 100) {
            let minDistance = Infinity;
            let nearestT = 0;
            
            for (let i = 0; i <= samples; i++) {
                const t = i / samples;
                const pointOnCurve = curve.getPointAt(t);
                const distance = targetPoint.distanceTo(pointOnCurve);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestT = t;
                }
            }
            
            return nearestT;
        }
        
        function initTransformControls() {
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.setMode('translate'); // Mặc định là translate (di chuyển)
            transformControls.addEventListener('dragging-changed', (event) => {
                // Tạm thời vô hiệu hóa OrbitControls khi đang kéo khối
                controls.enabled = !event.value;
                
                // Cập nhật isBeingDragged flag cho AGV đang được chọn
                if (selectedAGV) {
                    selectedAGV.isBeingDragged = event.value;
                    
                    // Khi thả AGV, tìm điểm gần nhất trên curve và cập nhật curvePosition
                    if (!event.value) {
                        const currentPos = new THREE.Vector3(
                            selectedAGV.group.position.x,
                            0,
                            selectedAGV.group.position.z
                        );
                        const nearestT = findNearestPointOnCurve(selectedAGV.curve, currentPos);
                        selectedAGV.curvePosition = nearestT;
                        // Cập nhật currentX và currentZ từ curve
                        const curvePos = selectedAGV.curve.getPointAt(nearestT);
                        selectedAGV.currentX = curvePos.x;
                        selectedAGV.currentZ = curvePos.z;
                        
                        // Tính góc xoay từ path tại vị trí hiện tại
                        const tangent = selectedAGV.curve.getTangentAt(nearestT);
                        const pathRotation = Math.atan2(tangent.x, tangent.z);
                        
                        // Tính góc offset = góc xoay hiện tại - góc xoay từ path
                        const currentRotation = selectedAGV.group.rotation.y;
                        selectedAGV.rotationOffset = currentRotation - pathRotation;
                    }
                }
                
                // Xử lý control point khi đang tạo path
                if (isCreatingPath && selectedControlPoint) {
                    if (!event.value) {
                        const marker = transformControls.object;
                        if (marker && marker.userData) {
                            const segmentIndex = selectedControlPoint.segmentIndex;
                            const cpType = selectedControlPoint.controlPoint;
                            
                            if (newPathControlPoints[segmentIndex] && newPathControlPoints[segmentIndex][cpType]) {
                                newPathControlPoints[segmentIndex][cpType].x = marker.position.x;
                                newPathControlPoints[segmentIndex][cpType].z = marker.position.z;
                                updateNewPathPreview();
                            }
                            justReleasedFromControlPointDrag = true;
                            transformControls.detach();
                            selectedControlPoint = null;
                            // Không bật OrbitControls ở đây — giữ tắt trong suốt lúc tạo path để click cp2 không xoay camera
                        }
                    }
                }
            });
            
            // Lắng nghe sự kiện objectChange để cập nhật real-time khi kéo
            transformControls.addEventListener('objectChange', () => {
                if (isCreatingPath && selectedControlPoint) {
                    const marker = transformControls.object;
                    if (marker && marker.userData) {
                        const segmentIndex = selectedControlPoint.segmentIndex;
                        const cpType = selectedControlPoint.controlPoint;
                        
                        // Giữ Y cố định (chỉ di chuyển trên mặt phẳng)
                        marker.position.y = 0.6;
                        
                        if (newPathControlPoints[segmentIndex] && newPathControlPoints[segmentIndex][cpType]) {
                            // Cập nhật control point real-time
                            newPathControlPoints[segmentIndex][cpType].x = marker.position.x;
                            newPathControlPoints[segmentIndex][cpType].z = marker.position.z;
                            
                            // Cập nhật preview
                            updateNewPathPreview();
                            
                            // Cập nhật lại các đường nối control points
                            updateControlPointLines(segmentIndex);
                        }
                    }
                }
            });
            
            scene.add(transformControls);
        }
        
        // Tạo khối mới
        function createBlock(position = [0, 1, 0], size = [2, 2, 2], color = 0x888888) {
            const geometry = new THREE.BoxGeometry(...size);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.3,
                roughness: 0.7
            });
            const block = new THREE.Mesh(geometry, material);
            block.position.set(...position);
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData = {
                id: blocks.length,
                type: 'block',
                originalSize: [...size]
            };
            
            // Thêm outline để dễ nhìn
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
            );
            block.add(line);
            
            scene.add(block);
            blocks.push(block);
            
            return block;
        }
        
        // Import đối tượng 3D từ file
        function importObject(file, position = [0, 0, 0]) {
            const fileName = file.name.toLowerCase();
            const fileExtension = fileName.split('.').pop();
            
            console.log('Bắt đầu import file:', file.name, 'Extension:', fileExtension);
            
            // Kiểm tra loaders
            const loadersAvailable = {
                gltf: typeof THREE.GLTFLoader !== 'undefined',
                obj: typeof THREE.OBJLoader !== 'undefined',
                fbx: typeof THREE.FBXLoader !== 'undefined'
            };
            
            console.log('Loaders available:', loadersAvailable);
            
            // Tạo container group cho object
            const objectGroup = new THREE.Group();
            objectGroup.position.set(...position);
            objectGroup.userData = {
                id: blocks.length,
                type: 'imported',
                fileName: file.name,
                fileExtension: fileExtension
            };
            
            // Hàm xử lý sau khi load
            const onLoad = (object) => {
                if (!object) {
                    onError(new Error('Object không được load'));
                    return;
                }
                
                // Đảm bảo object có thể cast và receive shadow
                object.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // Tính toán bounding box ban đầu
                let box = new THREE.Box3().setFromObject(object);
                let size = box.getSize(new THREE.Vector3());
                
                // Scale nếu object quá lớn hoặc quá nhỏ (trước khi center)
                const maxDimension = Math.max(size.x, size.y, size.z);
                if (maxDimension > 20) {
                    const scale = 20 / maxDimension;
                    object.scale.set(scale, scale, scale);
                    // Tính lại bounding box sau khi scale
                    box = new THREE.Box3().setFromObject(object);
                    size = box.getSize(new THREE.Vector3());
                } else if (maxDimension < 0.5) {
                    const scale = 2 / maxDimension;
                    object.scale.set(scale, scale, scale);
                    // Tính lại bounding box sau khi scale
                    box = new THREE.Box3().setFromObject(object);
                    size = box.getSize(new THREE.Vector3());
                }
                
                // Center object theo X và Z, nhưng đặt bottom trên floor (Y = 0)
                const center = box.getCenter(new THREE.Vector3());
                const minY = box.min.y; // Bottom của object
                
                // Center theo X và Z
                object.position.x -= center.x;
                object.position.z -= center.z;
                
                // Đặt bottom của object trên floor (y = 0)
                // Nếu minY < 0, object đang ở dưới origin, cần nâng lên
                // Nếu minY > 0, object đang ở trên origin, cần hạ xuống
                object.position.y -= minY; // Đặt bottom ở y = 0
                
                // Tính lại bounding box sau khi di chuyển
                box = new THREE.Box3().setFromObject(object);
                
                objectGroup.add(object);
                
                // Đảm bảo objectGroup được đặt đúng vị trí trên floor
                // Giữ nguyên X và Z từ position parameter, nhưng đảm bảo Y = 0
                objectGroup.position.x = position[0];
                objectGroup.position.y = 0; // Luôn đặt trên floor
                objectGroup.position.z = position[2];
                
                // Verify: Tính lại bounding box để đảm bảo bottom ở y = 0
                box = new THREE.Box3().setFromObject(objectGroup);
                if (Math.abs(box.min.y) > 0.01) {
                    // Nếu bottom không ở y = 0, điều chỉnh lại
                    objectGroup.position.y -= box.min.y;
                }
                
                scene.add(objectGroup);
                blocks.push(objectGroup);
                
                // Tự động chọn object vừa import
                selectBlock(objectGroup);
                
                console.log('Đã import object thành công:', file.name);
                alert('Đã import thành công: ' + file.name);
            };
            
            // Hàm xử lý lỗi
            const onError = (error) => {
                console.error('Lỗi khi import object:', error);
                const errorMsg = error && error.message ? error.message : String(error);
                alert('Lỗi khi import file: ' + file.name + '\n' + errorMsg + '\n\nVui lòng kiểm tra:\n1. File có đúng định dạng không\n2. Loaders đã được load chưa\n3. Console để xem chi tiết lỗi');
            };
            
            // Load file dựa trên extension
            const fileURL = URL.createObjectURL(file);
            
            try {
                if (fileExtension === 'gltf' || fileExtension === 'glb') {
                    // GLTF/GLB
                    if (!loadersAvailable.gltf) {
                        URL.revokeObjectURL(fileURL);
                        alert('GLTFLoader chưa được load. Vui lòng kiểm tra lại CDN link.');
                        console.error('THREE.GLTFLoader is undefined');
                        return;
                    }
                    const loader = new THREE.GLTFLoader();
                    loader.load(
                        fileURL,
                        (gltf) => {
                            URL.revokeObjectURL(fileURL);
                            if (gltf && gltf.scene) {
                                onLoad(gltf.scene);
                            } else {
                                onError(new Error('GLTF scene không hợp lệ'));
                            }
                        },
                        (progress) => {
                            if (progress.lengthComputable) {
                                const percent = (progress.loaded / progress.total) * 100;
                                console.log('Loading progress:', percent.toFixed(2) + '%');
                            }
                        },
                        (error) => {
                            URL.revokeObjectURL(fileURL);
                            onError(error);
                        }
                    );
                } else if (fileExtension === 'obj') {
                    // OBJ
                    if (!loadersAvailable.obj) {
                        URL.revokeObjectURL(fileURL);
                        alert('OBJLoader chưa được load. Vui lòng kiểm tra lại CDN link.');
                        console.error('THREE.OBJLoader is undefined');
                        return;
                    }
                    const loader = new THREE.OBJLoader();
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const object = loader.parse(e.target.result);
                            URL.revokeObjectURL(fileURL);
                            onLoad(object);
                        } catch (err) {
                            URL.revokeObjectURL(fileURL);
                            onError(err);
                        }
                    };
                    reader.onerror = (err) => {
                        URL.revokeObjectURL(fileURL);
                        onError(new Error('Lỗi khi đọc file OBJ: ' + err));
                    };
                    reader.readAsText(file);
                } else if (fileExtension === 'fbx') {
                    // FBX
                    if (!loadersAvailable.fbx) {
                        URL.revokeObjectURL(fileURL);
                        alert('FBXLoader chưa được load. Vui lòng kiểm tra lại CDN link.');
                        console.error('THREE.FBXLoader is undefined');
                        return;
                    }
                    const loader = new THREE.FBXLoader();
                    loader.load(
                        fileURL,
                        (object) => {
                            URL.revokeObjectURL(fileURL);
                            onLoad(object);
                        },
                        (progress) => {
                            if (progress.lengthComputable) {
                                const percent = (progress.loaded / progress.total) * 100;
                                console.log('Loading progress:', percent.toFixed(2) + '%');
                            }
                        },
                        (error) => {
                            URL.revokeObjectURL(fileURL);
                            onError(error);
                        }
                    );
                } else {
                    URL.revokeObjectURL(fileURL);
                    alert('Định dạng file không được hỗ trợ: .' + fileExtension + '\nHỗ trợ: .gltf, .glb, .obj, .fbx');
                    return;
                }
            } catch (err) {
                URL.revokeObjectURL(fileURL);
                onError(err);
            }
        }
        
        // Chọn khối
        function selectBlock(block) {
            if (selectedBlock === block) return;
            
            // Bỏ chọn khối cũ
            if (selectedBlock) {
                // Xử lý cả block và imported object
                if (selectedBlock.material) {
                    // Cube block
                    selectedBlock.material.emissive.setHex(0x000000);
                } else if (selectedBlock.userData && selectedBlock.userData.type === 'imported') {
                    // Bỏ highlight imported object - đảm bảo material có emissive
                    selectedBlock.traverse((child) => {
                        if (child.isMesh && child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    if (mat.emissive) {
                                        mat.emissive.setHex(0x000000);
                                    }
                                });
                            } else {
                                if (child.material.emissive) {
                                    child.material.emissive.setHex(0x000000);
                                }
                            }
                        }
                    });
                }
            }
            
            // Chọn khối mới
            selectedBlock = block;
            if (block) {
                // Highlight
                if (block.material) {
                    // Cube block
                    block.material.emissive.setHex(0x444444);
                } else if (block.userData && block.userData.type === 'imported') {
                    // Highlight imported object - đảm bảo material có emissive
                    block.traverse((child) => {
                        if (child.isMesh && child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    if (!mat.emissive) {
                                        mat.emissive = new THREE.Color(0x000000);
                                    }
                                    mat.emissive.setHex(0x444444);
                                });
                            } else {
                                if (!child.material.emissive) {
                                    child.material.emissive = new THREE.Color(0x000000);
                                }
                                child.material.emissive.setHex(0x444444);
                            }
                        }
                    });
                }
                transformControls.attach(block);
                
                // Bỏ chọn AGV nếu có
                if (selectedAGV) {
                    selectAGV(null);
                }
            } else {
                transformControls.detach();
            }
        }
        
        // Chọn AGV
        function selectAGV(agv) {
            if (selectedAGV === agv) return;
            
            // Bỏ chọn AGV cũ
            if (selectedAGV) {
                // Bỏ highlight
                selectedAGV.group.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                if (mat.emissive) mat.emissive.setHex(0x000000);
                            });
                        } else {
                            if (child.material.emissive) {
                                child.material.emissive.setHex(0x000000);
                            }
                        }
                    }
                });
            }
            
            // Chọn AGV mới
            selectedAGV = agv;
            if (agv) {
                // Highlight AGV
                agv.group.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                if (!mat.emissive) {
                                    mat.emissive = new THREE.Color(0x000000);
                                }
                                mat.emissive.setHex(0x00ffff); // Cyan highlight cho AGV
                            });
                        } else {
                            if (!child.material.emissive) {
                                child.material.emissive = new THREE.Color(0x000000);
                            }
                            child.material.emissive.setHex(0x00ffff); // Cyan highlight cho AGV
                        }
                    }
                });
                
                // Attach TransformControls vào AGV group để có thể di chuyển, xoay, scale
                if (transformControls) {
                    transformControls.attach(agv.group);
                }
            } else {
                // Bỏ chọn AGV - detach TransformControls
                if (transformControls) {
                    transformControls.detach();
                }
            }
            
            // Cập nhật config và agvInfo để hiển thị thông tin AGV đã chọn
            if (typeof config !== 'undefined') {
                config.selectedAGVId = agv ? agv.id : 'Chưa chọn AGV';
                config.hasImportedModel = agv ? !agv.isUsingDefaultModel : false;
            }
            // Cập nhật agvInfo cho dat.GUI
            if (typeof agvInfo !== 'undefined') {
                agvInfo.selectedAGVId = agv ? agv.id : 'Chưa chọn AGV';
                agvInfo.hasImportedModel = agv ? !agv.isUsingDefaultModel : false;
            }
        }
        
        // Xóa khối
        function deleteBlock(block) {
            const index = blocks.indexOf(block);
            if (index > -1) {
                if (selectedBlock === block) {
                    selectBlock(null);
                }
                scene.remove(block);
                
                // Dispose geometry và material
                if (block.geometry) {
                    block.geometry.dispose();
                }
                if (block.material) {
                    if (Array.isArray(block.material)) {
                        block.material.forEach(mat => mat.dispose());
                    } else {
                        block.material.dispose();
                    }
                }
                
                // Nếu là imported object (Group), dispose tất cả children
                if (block.userData && block.userData.type === 'imported') {
                    block.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }
                
                blocks.splice(index, 1);
            }
        }
        
        // Xóa tất cả khối
        function clearAllBlocks() {
            blocks.forEach(block => {
                scene.remove(block);
                
                // Dispose geometry và material
                if (block.geometry) {
                    block.geometry.dispose();
                }
                if (block.material) {
                    if (Array.isArray(block.material)) {
                        block.material.forEach(mat => mat.dispose());
                    } else {
                        block.material.dispose();
                    }
                }
                
                // Nếu là imported object (Group), dispose tất cả children
                if (block.userData && block.userData.type === 'imported') {
                    block.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }
            });
            blocks.length = 0;
            selectBlock(null);
        }
        
        // Thay đổi mode của TransformControls
        function setTransformMode(mode) {
            if (transformControls) {
                transformControls.setMode(mode); // 'translate', 'rotate', 'scale'
            }
        }
        
        // Khởi tạo TransformControls
        initTransformControls();
        
        // Xử lý click để chọn khối (raycaster, mouse, setMouseFromEvent đã khai báo trước OrbitControls)
        function onMouseClick(event) {
            if (transformControls.dragging) return;
            
            setMouseFromEvent(event);
            raycaster.setFromCamera(mouse, camera);
            
            if (isCreatingPath && event.button === 0) {
                // Ưu tiên: nếu click vào control point thì chỉ return (đã chọn trong onMouseDown), không tạo waypoint
                if (newPathControlPointMarkers) {
                    scene.updateMatrixWorld(true);
                    const allHits = raycaster.intersectObject(newPathControlPointMarkers, true);
                    const controlPointHit = allHits.find(hr => hr.object.isMesh && hr.object.userData && hr.object.userData.controlPoint);
                    if (controlPointHit) {
                        justReleasedFromControlPointDrag = false; // Cho phép lần click sau chọn control point khác
                        return;
                    }
                }
                // Vừa thả sau khi kéo control point và giờ click vào floor → không tạo waypoint
                if (justReleasedFromControlPointDrag) {
                    justReleasedFromControlPointDrag = false;
                    return;
                }
                
                // Click vào floor để thêm waypoint — bỏ chọn control point trước (giữ OrbitControls tắt đến khi Hủy/Hoàn thành path)
                if (selectedControlPoint && transformControls && transformControls.object) {
                    transformControls.detach();
                    selectedControlPoint = null;
                }
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);
                if (Math.abs(intersectPoint.x) <= 100 && Math.abs(intersectPoint.z) <= 100) {
                    handlePathCreationClick(intersectPoint);
                }
                return;
            }
            
            // Kiểm tra click vào AGV trước
            const agvGroups = agvs.map(agv => agv.group);
            const agvIntersects = raycaster.intersectObjects(agvGroups, true);
            
            if (agvIntersects.length > 0) {
                // Click vào AGV
                let clickedObject = agvIntersects[0].object;
                
                // Tìm AGV parent
                let agvParent = null;
                let current = clickedObject;
                while (current && !agvParent) {
                    if (agvGroups.includes(current)) {
                        agvParent = agvs.find(agv => agv.group === current);
                        break;
                    }
                    current = current.parent;
                }
                
                if (agvParent) {
                    selectAGV(agvParent);
                    // Bỏ chọn block nếu có
                    if (selectedBlock) {
                        selectBlock(null);
                    }
                }
                return;
            }
            
            // Xử lý chọn khối như bình thường
            // Intersect với tất cả objects trong blocks (bao gồm cả children của imported objects)
            const intersects = raycaster.intersectObjects(blocks, true); // true = recursive, intersect với children
            
            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                
                // Nếu click vào child của imported object (Group), tìm parent group
                if (clickedObject.userData && clickedObject.userData.type === 'imported') {
                    // Đã click trực tiếp vào group
                    selectBlock(clickedObject);
                } else {
                    // Click vào child, tìm parent group trong blocks
                    let parentGroup = null;
                    let current = clickedObject;
                    
                    // Tìm parent group trong blocks
                    while (current && !parentGroup) {
                        if (blocks.includes(current)) {
                            parentGroup = current;
                            break;
                        }
                        current = current.parent;
                    }
                    
                    if (parentGroup) {
                        selectBlock(parentGroup);
                    } else {
                        // Nếu không tìm thấy parent group, có thể là cube block
                        selectBlock(clickedObject);
                    }
                }
                // Bỏ chọn AGV nếu có
                if (selectedAGV) {
                    selectAGV(null);
                }
            } else {
                // Click vào không gian trống để bỏ chọn
                if (event.button === 0) { // Left click only
                    selectBlock(null);
                    selectAGV(null);
                }
            }
        }
        
        renderer.domElement.addEventListener('click', onMouseClick);
        
        // Xử lý hover và drag control points
        let isDraggingControlPoint = false;
        
        function onMouseMove(event) {
            if (!isCreatingPath || !newPathControlPointMarkers) {
                renderer.domElement.style.cursor = 'default';
                return;
            }
            
            setMouseFromEvent(event);
            scene.updateMatrixWorld(true);
            raycaster.setFromCamera(mouse, camera);
            
            if (selectedControlPoint) {
                renderer.domElement.style.cursor = 'move';
                return;
            }
            const allHits = raycaster.intersectObject(newPathControlPointMarkers, true);
            const overControlPoint = allHits.some(hr => hr.object.isMesh && hr.object.userData && hr.object.userData.controlPoint);
            if (overControlPoint) {
                renderer.domElement.style.cursor = 'pointer';
                return;
            }
            renderer.domElement.style.cursor = isCreatingPath ? 'crosshair' : 'default';
        }
        
        function onMouseDown(event) {
            if (!isCreatingPath || !newPathControlPointMarkers || event.button !== 0) return;
            
            setMouseFromEvent(event);
            scene.updateMatrixWorld(true);
            raycaster.setFromCamera(mouse, camera);
            // Raycast vào cả group (recursive), lấy hit đầu tiên là mesh có userData.controlPoint
            const allIntersects = raycaster.intersectObject(newPathControlPointMarkers, true);
            const controlPointHit = allIntersects.find(hr => hr.object.isMesh && hr.object.userData && hr.object.userData.controlPoint);
            
            if (controlPointHit) {
                const clickedObject = controlPointHit.object;
                event.preventDefault();
                isDraggingControlPoint = true;
                if (transformControls && transformControls.object !== clickedObject) {
                    transformControls.detach();
                }
                selectedControlPoint = {
                    segmentIndex: clickedObject.userData.segmentIndex,
                    controlPoint: clickedObject.userData.controlPoint
                };
                if (transformControls) {
                    transformControls.attach(clickedObject);
                }
                if (controls) controls.enabled = false; // Tắt OrbitControls khi đang kéo control point
            }
        }
        
        function onMouseUp(event) {
            if (event.button === 0) {
                if (isDraggingControlPoint) justReleasedFromControlPointDrag = true; // Vừa kéo control point → click sau không tạo waypoint
                isDraggingControlPoint = false;
            }
        }
        
        let justReleasedFromControlPointDrag = false;
        _onControlPointMouseDown = onMouseDown;

        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);

        // Helper functions để giảm boilerplate
        const Helpers = {
            createMesh: (geometry, material, position = [0, 0, 0], castShadow = false, receiveShadow = false) => {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(...position);
                mesh.castShadow = castShadow;
                mesh.receiveShadow = receiveShadow;
                return mesh;
            },
            
            createBox: (size, material, position = [0, 0, 0]) => {
                const geometry = new THREE.BoxGeometry(...size);
                return Helpers.createMesh(geometry, material, position, true, true);
            },
            
            animateCamera: (camera, target, duration = 1) => {
                if (typeof gsap !== 'undefined') {
                    gsap.to(camera.position, {
                        x: target.x,
                        y: target.y,
                        z: target.z,
                        duration: duration,
                        ease: "power2.inOut"
                    });
                } else {
                    // Fallback: set trực tiếp
                    camera.position.set(target.x, target.y, target.z);
                }
            }
        };

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(-50, 30, -50);
        scene.add(pointLight);

        // Building: khi mới vào chỉ 1 tầng trống, người dùng thêm tầng/path/AGV qua Studio
        const building = {
            floors: [
                { id: 'F1', name: 'Tầng 1', elevation: 0, width: 200, depth: 200 }
            ]
        };

        // Thang máy: ban đầu không có, người dùng thêm qua Studio
        const elevators = [];

        // Create floor/map — render theo từng tầng (lưu ref để rebuild Studio)
        const floorMeshes = [], gridHelpers = [], wallMeshes = [];
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.8,
            metalness: 0.2
        });
        const wallHeight = 5;
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.7 });
        function createFloorsAndWalls() {
            building.floors.forEach((floorDef) => {
                const floorGeometry = new THREE.PlaneGeometry(floorDef.width, floorDef.depth);
                const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial.clone());
                floorMesh.rotation.x = -Math.PI / 2;
                floorMesh.position.y = floorDef.elevation;
                floorMesh.receiveShadow = true;
                scene.add(floorMesh);
                floorMeshes.push(floorMesh);
                const gridHelper = new THREE.GridHelper(floorDef.width, 20, 0x444444, 0x333333);
                gridHelper.position.y = floorDef.elevation;
                scene.add(gridHelper);
                gridHelpers.push(gridHelper);
                const hw = floorDef.width / 2, hd = floorDef.depth / 2;
                const yWall = floorDef.elevation + wallHeight / 2;
                [
                    [floorDef.width, wallHeight, 2, [0, yWall, -hd]],
                    [floorDef.width, wallHeight, 2, [0, yWall, hd]],
                    [2, wallHeight, floorDef.depth, [-hw, yWall, 0]],
                    [2, wallHeight, floorDef.depth, [hw, yWall, 0]]
                ].forEach(([w, h, d, pos]) => {
                    const wall = Helpers.createBox([w, h, d], wallMaterial, pos);
                    scene.add(wall);
                    wallMeshes.push(wall);
                });
            });
        }
        createFloorsAndWalls();

        // Render thang máy (mesh tại mỗi cửa thang trên từng tầng)
        const elevatorMaterial = new THREE.MeshStandardMaterial({ color: 0x37474f, roughness: 0.6, metalness: 0.3 });
        const elevatorMeshes = [];
        function createElevatorMeshes() {
            elevatorMeshes.forEach(m => { scene.remove(m); if (m.geometry) m.geometry.dispose(); if (m.material) m.material.dispose(); });
            elevatorMeshes.length = 0;
            elevators.forEach((elevator) => {
                elevator.floorIds.forEach((floorId) => {
                    const pos = elevator.positions[floorId];
                    if (!pos) return;
                    const floorDef = building.floors.find(f => f.id === floorId);
                    if (!floorDef) return;
                    const box = Helpers.createBox([4, 3, 4], elevatorMaterial, [pos.x, floorDef.elevation + 1.5, pos.z]);
                    box.userData = { elevatorId: elevator.id, floorId };
                    scene.add(box);
                    elevatorMeshes.push(box);
                });
            });
        }
        createElevatorMeshes();
        function rebuildFloorsAndElevators() {
            floorMeshes.forEach(m => { scene.remove(m); if (m.geometry) m.geometry.dispose(); if (m.material) m.material.dispose(); });
            floorMeshes.length = 0;
            gridHelpers.forEach(m => { scene.remove(m); });
            gridHelpers.length = 0;
            wallMeshes.forEach(m => { scene.remove(m); if (m.geometry) m.geometry.dispose(); if (m.material) m.material.dispose(); });
            wallMeshes.length = 0;
            createFloorsAndWalls();
            createElevatorMeshes();
        }

        // Không thêm obstacle mặc định — người dùng thêm khối/đối tượng qua UI nếu cần

        // Helper: elevation theo tầng (path/AGV dùng độ cao sàn + 0.1 cho đường path)
        function getFloorElevation(floorId) {
            const f = building.floors.find(f => f.id === (floorId || 'F1'));
            return f ? f.elevation : 0;
        }
        function getPathElevation(pathObj) {
            return getFloorElevation(pathObj && pathObj.floorId) + 0.1;
        }

        // Path definitions — ban đầu trống, người dùng tạo path qua "Tạo Path Mới"
        const pathDefinitions = [];
        
        // Tên các path để hiển thị trong dropdown
        let pathNames = [];
        
        // Endpoints: điểm trên map/path mà AGV đi qua thì gửi event
        const endpoints = []; // { id, name, type: 'standalone', x, z, floorId }
        const endpointMeshes = [];
        function getEndpointPosition(ep) {
            if (ep.type === 'path' && ep.pathIndex != null && pathDefinitions[ep.pathIndex]) {
                const path = pathDefinitions[ep.pathIndex];
                const pts = path.points;
                const idx = Math.min(ep.pointIndex != null ? ep.pointIndex : 0, pts.length - 1);
                const p = pts[idx];
                return { x: p.x, z: p.z, y: getFloorElevation(path.floorId) + 0.1 };
            }
            return { x: ep.x || 0, z: ep.z || 0, y: getFloorElevation(ep.floorId) + 0.1 };
        }
        function onEndpointReached(agvId, endpointId) {
            console.log('Endpoint reached:', agvId, endpointId);
        }
        function addEndpoint(ep) {
            if (!ep.id) ep.id = 'EP-' + (endpoints.length + 1);
            endpoints.push(ep);
            const pos = getEndpointPosition(ep);
            const geom = new THREE.SphereGeometry(1.5, 16, 16);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff9800, emissive: 0xff9800, emissiveIntensity: 0.3 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.userData = { endpointId: ep.id };
            scene.add(mesh);
            endpointMeshes.push({ id: ep.id, mesh });
        }
        function getStudioConfig() {
            return { building, elevators, pathDefinitions, pathNames, endpoints };
        }
        function saveStudioConfig() {
            const json = JSON.stringify(getStudioConfig(), null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'studio-config.json';
            a.click();
            URL.revokeObjectURL(a.href);
        }
        function loadStudioConfig(jsonStr) {
            try {
                const data = JSON.parse(jsonStr);
                if (data.building && data.building.floors) building.floors = data.building.floors;
                if (Array.isArray(data.elevators)) { elevators.length = 0; elevators.push(...data.elevators); }
                if (Array.isArray(data.pathDefinitions)) { pathDefinitions.length = 0; pathDefinitions.push(...data.pathDefinitions); }
                if (Array.isArray(data.pathNames)) { pathNames.length = 0; pathNames.push(...data.pathNames); }
                if (Array.isArray(data.endpoints)) {
                    endpointMeshes.forEach(o => { scene.remove(o.mesh); o.mesh.geometry.dispose(); o.mesh.material.dispose(); });
                    endpointMeshes.length = 0;
                    endpoints.length = 0;
                    data.endpoints.forEach(ep => addEndpoint(ep));
                }
                rebuildFloorsAndElevators();
                if (typeof config !== 'undefined') {
                    config.selectedPathIndex = 0;
                    config.selectedPathName = pathNames[0] || '';
                    config.currentFloorId = building.floors[0] ? building.floors[0].id : 'F1';
                }
                if (typeof refreshDesktopUI === 'function') refreshDesktopUI();
            } catch (e) { console.error('Load config failed:', e); alert('Tải cấu hình thất bại: ' + e.message); }
        }
        
        // Hệ thống lưu và hiển thị paths độc lập (không gắn với AGV)
        const standalonePaths = []; // Mảng lưu các path visualization độc lập
        const defaultPathColor = 0x888888; // Màu mặc định cho path không có AGV
        
        // Hệ thống tạo path mới
        let isCreatingPath = false; // Mode tạo path
        let newPathWaypoints = []; // Các waypoint đang được tạo
        let newPathSegmentTypes = []; // Type của từng segment (từ waypoint i đến i+1)
        let newPathControlPoints = []; // Control points cho các segment bezier (mỗi phần tử là {cp1: {x, z}, cp2: {x, z}} hoặc null nếu linear)
        let newPathPreview = null; // Preview line của path đang tạo
        let newPathMarkers = null; // Markers của các waypoint đang tạo
        let newPathControlPointMarkers = null; // Markers của các control points
        let selectedControlPoint = null; // Control point đang được chọn để di chuyển
        let newPathType = 'bezier'; // Loại path hiện tại (áp dụng cho segment mới)
        
        // Bắt đầu tạo path mới
        function startCreatingPath() {
            if (isCreatingPath) {
                // Nếu đang tạo path, hủy bỏ
                cancelCreatingPath();
                return;
            }
            
            isCreatingPath = true;
            newPathWaypoints = [];
            newPathSegmentTypes = [];
            newPathControlPoints = [];
            selectedControlPoint = null;
            isDraggingControlPoint = false;
            justReleasedFromControlPointDrag = false;
            // Đồng bộ newPathType với config
            if (typeof config !== 'undefined' && config.newPathType) {
                newPathType = config.newPathType;
            }
            
            // Xóa preview cũ nếu có
            if (newPathPreview) {
                scene.remove(newPathPreview);
                newPathPreview = null;
            }
            if (newPathMarkers) {
                newPathMarkers.children.forEach(child => scene.remove(child));
                scene.remove(newPathMarkers);
                newPathMarkers = null;
            }
            if (newPathControlPointMarkers) {
                newPathControlPointMarkers.children.forEach(child => scene.remove(child));
                scene.remove(newPathControlPointMarkers);
                newPathControlPointMarkers = null;
            }
            
            // Tạo group cho markers
            newPathMarkers = new THREE.Group();
            scene.add(newPathMarkers);
            
            // Tạo group cho control point markers
            newPathControlPointMarkers = new THREE.Group();
            scene.add(newPathControlPointMarkers);
            
            renderer.domElement.style.cursor = 'crosshair';
            // Tắt OrbitControls khi đang tạo path → click vào control point không xoay camera
            if (controls) controls.enabled = false;
            
            if (typeof config !== 'undefined') {
                config.isCreatingPath = true;
            }
        }
        
        // Hủy tạo path
        function cancelCreatingPath() {
            isCreatingPath = false;
            newPathWaypoints = [];
            newPathSegmentTypes = [];
            newPathControlPoints = [];
            selectedControlPoint = null;
            isDraggingControlPoint = false;
            justReleasedFromControlPointDrag = false;
            
            if (newPathPreview) {
                scene.remove(newPathPreview);
                newPathPreview = null;
            }
            if (newPathMarkers) {
                newPathMarkers.children.forEach(child => scene.remove(child));
                scene.remove(newPathMarkers);
                newPathMarkers = null;
            }
            if (newPathControlPointMarkers) {
                newPathControlPointMarkers.children.forEach(child => scene.remove(child));
                scene.remove(newPathControlPointMarkers);
                newPathControlPointMarkers = null;
            }
            
            if (transformControls && transformControls.object) {
                transformControls.detach();
            }
            if (controls) controls.enabled = true;
            
            renderer.domElement.style.cursor = 'default';
            
            if (typeof config !== 'undefined') {
                config.isCreatingPath = false;
            }
        }
        
        // Hoàn thành tạo path
        function finishCreatingPath() {
            if (newPathWaypoints.length < 2) {
                alert('Path cần ít nhất 2 waypoint!');
                return;
            }
            
            // Lưu path mới với segmentTypes và control points đã thu thập
            const newPathPoints = newPathWaypoints.map(wp => ({ x: wp.x, z: wp.z }));
            // Sử dụng segmentTypes đã thu thập khi thêm waypoint
            // Nếu chưa đủ (có thể xảy ra nếu chỉ có 1 waypoint), bổ sung bằng type hiện tại
            const segmentTypes = [...newPathSegmentTypes];
            while (segmentTypes.length < newPathPoints.length) {
                segmentTypes.push(newPathType);
            }
            // Lưu control points (chỉ cho bezier segments)
            const controlPoints = newPathControlPoints.map(cp => {
                if (cp && cp.cp1 && cp.cp2) {
                    return { cp1: { x: cp.cp1.x, z: cp.cp1.z }, cp2: { x: cp.cp2.x, z: cp.cp2.z } };
                }
                return null;
            });
            const newPath = {
                floorId: (typeof config !== 'undefined' && config.currentFloorId) ? config.currentFloorId : building.floors[0].id,
                points: newPathPoints,
                segmentTypes: segmentTypes,
                controlPoints: controlPoints
            };
            pathDefinitions.push(newPath);
            
            const newPathName = `Path ${pathDefinitions.length}`;
            pathNames.push(newPathName);
            
            if (typeof config !== 'undefined') {
                config.selectedPathIndex = pathDefinitions.length - 1;
                config.selectedPathName = newPathName;
            }
            
            cancelCreatingPath();
            
            const pathIndex = pathDefinitions.length - 1;
            const pathVisual = createPathLine(newPath, defaultPathColor);
            // Đảm bảo visibility theo pathsVisible hiện tại
            pathVisual.line.visible = pathsVisible;
            pathVisual.markers.visible = pathsVisible;
            standalonePaths.push({
                pathIndex: pathIndex,
                line: pathVisual.line,
                markers: pathVisual.markers,
                visible: pathsVisible
            });
            
            // Cập nhật GUI
            if (gui) {
                // Tìm và cập nhật dropdown
                const controllers = gui.__controllers || [];
                controllers.forEach(controller => {
                    if (controller.property === 'selectedPathName') {
                        // Cập nhật options và value
                        if (controller.domElement && controller.domElement.tagName === 'SELECT') {
                            const select = controller.domElement;
                            // Thêm option mới
                            const option = document.createElement('option');
                            option.value = newPathName;
                            option.textContent = newPathName;
                            select.appendChild(option);
                            // Chọn option mới
                            select.value = newPathName;
                        }
                        controller.updateDisplay();
                    }
                });
            }
            
            if (typeof refreshDesktopUI === 'function') refreshDesktopUI();
            alert(`Đã tạo path mới: ${newPathName} với ${newPathWaypoints.length} waypoint!`);
        }
        
        // Thêm waypoint vào path đang tạo
        function addWaypointToNewPath(position) {
            if (!isCreatingPath) return;
            
            // Nếu đã có ít nhất 1 waypoint, lưu type và control points cho segment từ waypoint trước đến waypoint này
            if (newPathWaypoints.length > 0) {
                // Lưu type hiện tại cho segment mới
                newPathSegmentTypes.push(newPathType);
                
                // Nếu là bezier, tạo 2 control points mặc định
                if (newPathType === 'bezier') {
                    const prevWaypoint = newPathWaypoints[newPathWaypoints.length - 1];
                    const currentWaypoint = position;
                    
                    // Tính vector từ prevWaypoint đến currentWaypoint
                    const dx = currentWaypoint.x - prevWaypoint.x;
                    const dz = currentWaypoint.z - prevWaypoint.z;
                    
                    // Control point 1: ở 1/3 quãng đường từ prevWaypoint
                    const cp1 = {
                        x: prevWaypoint.x + dx * 0.33,
                        z: prevWaypoint.z + dz * 0.33
                    };
                    
                    // Control point 2: ở 2/3 quãng đường từ prevWaypoint
                    const cp2 = {
                        x: prevWaypoint.x + dx * 0.67,
                        z: prevWaypoint.z + dz * 0.67
                    };
                    
                    // Thêm một chút độ cong bằng cách dịch chuyển vuông góc với đường thẳng
                    const perpX = -dz;
                    const perpZ = dx;
                    const curveAmount = Math.sqrt(dx * dx + dz * dz) * 0.2; // 20% độ dài
                    const normalize = Math.sqrt(perpX * perpX + perpZ * perpZ);
                    if (normalize > 0) {
                        cp1.x += (perpX / normalize) * curveAmount;
                        cp1.z += (perpZ / normalize) * curveAmount;
                        cp2.x += (perpX / normalize) * curveAmount;
                        cp2.z += (perpZ / normalize) * curveAmount;
                    }
                    
                    newPathControlPoints.push({ cp1: cp1, cp2: cp2 });
                } else {
                    // Linear: không có control points
                    newPathControlPoints.push(null);
                }
            }
            
            // Push waypoint trước khi tạo control point markers để createControlPointMarkers có endpoint (4 điểm: start, cp1, cp2, end)
            newPathWaypoints.push(position);
            
            if (newPathWaypoints.length > 1 && newPathType === 'bezier' && newPathControlPoints[newPathControlPoints.length - 1]) {
                createControlPointMarkers(newPathControlPoints.length - 1, newPathControlPoints[newPathControlPoints.length - 1].cp1, newPathControlPoints[newPathControlPoints.length - 1].cp2);
            }
            
            // Tạo marker cho waypoint
            const markerGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const markerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00,
                emissive: 0x004400
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.copy(position);
            marker.position.y = 0.5;
            newPathMarkers.add(marker);
            
            // Cập nhật preview line
            updateNewPathPreview();
        }
        
        // Tạo markers cho control points
        function createControlPointMarkers(segmentIndex, cp1, cp2) {
            if (!newPathControlPointMarkers) return;
            
            // Xóa markers cũ của segment này nếu có
            const oldMarkers = newPathControlPointMarkers.children.filter(child => 
                child.userData.segmentIndex === segmentIndex
            );
            oldMarkers.forEach(marker => {
                newPathControlPointMarkers.remove(marker);
                scene.remove(marker);
            });
            
            // Sphere radius 1.0 để dễ click (raycast)
            const cp1Geometry = new THREE.SphereGeometry(1.0, 16, 16);
            const cp1Material = new THREE.MeshStandardMaterial({ 
                color: 0xff8800,
                emissive: 0x442200,
                transparent: false
            });
            const cp1Marker = new THREE.Mesh(cp1Geometry, cp1Material);
            cp1Marker.position.set(cp1.x, 0.6, cp1.z);
            cp1Marker.userData = { 
                segmentIndex: segmentIndex, 
                controlPoint: 'cp1',
                isHovered: false
            };
            cp1Marker.castShadow = true;
            newPathControlPointMarkers.add(cp1Marker);
            
            const cp2Geometry = new THREE.SphereGeometry(1.0, 16, 16);
            const cp2Material = new THREE.MeshStandardMaterial({ 
                color: 0xff8800,
                emissive: 0x442200,
                transparent: false
            });
            const cp2Marker = new THREE.Mesh(cp2Geometry, cp2Material);
            cp2Marker.position.set(cp2.x, 0.6, cp2.z);
            cp2Marker.userData = { 
                segmentIndex: segmentIndex, 
                controlPoint: 'cp2',
                isHovered: false
            };
            cp2Marker.castShadow = true;
            newPathControlPointMarkers.add(cp2Marker);
            
            // Vẽ đường nối từ waypoint đến control points (để dễ nhìn)
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xff8800, 
                opacity: 0.3, 
                transparent: true,
                linewidth: 1
            });
            
            // Đường từ waypoint đầu đến cp1
            const startWaypoint = newPathWaypoints[segmentIndex];
            const line1Points = [
                new THREE.Vector3(startWaypoint.x, 0.2, startWaypoint.z),
                new THREE.Vector3(cp1.x, 0.2, cp1.z)
            ];
            const line1Geometry = new THREE.BufferGeometry().setFromPoints(line1Points);
            const line1 = new THREE.Line(line1Geometry, lineMaterial);
            line1.userData = { segmentIndex: segmentIndex, type: 'controlLine' };
            newPathControlPointMarkers.add(line1);
            
            // Đường từ cp1 đến cp2
            const line2Points = [
                new THREE.Vector3(cp1.x, 0.2, cp1.z),
                new THREE.Vector3(cp2.x, 0.2, cp2.z)
            ];
            const line2Geometry = new THREE.BufferGeometry().setFromPoints(line2Points);
            const line2 = new THREE.Line(line2Geometry, lineMaterial);
            line2.userData = { segmentIndex: segmentIndex, type: 'controlLine' };
            newPathControlPointMarkers.add(line2);
            
            // Đường từ cp2 đến waypoint cuối
            const endWaypoint = newPathWaypoints[segmentIndex + 1];
            const line3Points = [
                new THREE.Vector3(cp2.x, 0.2, cp2.z),
                new THREE.Vector3(endWaypoint.x, 0.2, endWaypoint.z)
            ];
            const line3Geometry = new THREE.BufferGeometry().setFromPoints(line3Points);
            const line3 = new THREE.Line(line3Geometry, lineMaterial);
            line3.userData = { segmentIndex: segmentIndex, type: 'controlLine' };
            newPathControlPointMarkers.add(line3);
        }
        
        // Cập nhật đường nối control points khi di chuyển
        function updateControlPointLines(segmentIndex) {
            if (!newPathControlPointMarkers || !newPathControlPoints[segmentIndex]) return;
            
            const controlPoints = newPathControlPoints[segmentIndex];
            if (!controlPoints || !controlPoints.cp1 || !controlPoints.cp2) return;
            
            // Tìm các đường nối của segment này
            const lines = newPathControlPointMarkers.children.filter(child => 
                child.userData && child.userData.segmentIndex === segmentIndex && child.userData.type === 'controlLine'
            );
            
            // Xóa các đường cũ
            lines.forEach(line => {
                newPathControlPointMarkers.remove(line);
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            
            // Tạo lại các đường nối
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xff8800, 
                opacity: 0.3, 
                transparent: true,
                linewidth: 1
            });
            
            const startWaypoint = newPathWaypoints[segmentIndex];
            const endWaypoint = newPathWaypoints[segmentIndex + 1];
            
            // Đường từ waypoint đầu đến cp1
            const line1Points = [
                new THREE.Vector3(startWaypoint.x, 0.2, startWaypoint.z),
                new THREE.Vector3(controlPoints.cp1.x, 0.2, controlPoints.cp1.z)
            ];
            const line1Geometry = new THREE.BufferGeometry().setFromPoints(line1Points);
            const line1 = new THREE.Line(line1Geometry, lineMaterial);
            line1.userData = { segmentIndex: segmentIndex, type: 'controlLine' };
            newPathControlPointMarkers.add(line1);
            
            // Đường từ cp1 đến cp2
            const line2Points = [
                new THREE.Vector3(controlPoints.cp1.x, 0.2, controlPoints.cp1.z),
                new THREE.Vector3(controlPoints.cp2.x, 0.2, controlPoints.cp2.z)
            ];
            const line2Geometry = new THREE.BufferGeometry().setFromPoints(line2Points);
            const line2 = new THREE.Line(line2Geometry, lineMaterial);
            line2.userData = { segmentIndex: segmentIndex, type: 'controlLine' };
            newPathControlPointMarkers.add(line2);
            
            // Đường từ cp2 đến waypoint cuối
            const line3Points = [
                new THREE.Vector3(controlPoints.cp2.x, 0.2, controlPoints.cp2.z),
                new THREE.Vector3(endWaypoint.x, 0.2, endWaypoint.z)
            ];
            const line3Geometry = new THREE.BufferGeometry().setFromPoints(line3Points);
            const line3 = new THREE.Line(line3Geometry, lineMaterial);
            line3.userData = { segmentIndex: segmentIndex, type: 'controlLine' };
            newPathControlPointMarkers.add(line3);
        }
        
        // Cập nhật preview line của path đang tạo (elevation theo tầng đang chọn)
        function updateNewPathPreview() {
            if (newPathWaypoints.length < 2) {
                if (newPathPreview) {
                    scene.remove(newPathPreview);
                    newPathPreview = null;
                }
                return;
            }
            
            if (newPathPreview) {
                scene.remove(newPathPreview);
            }
            
            const floorId = (typeof config !== 'undefined' && config.currentFloorId) ? config.currentFloorId : building.floors[0].id;
            const y = getFloorElevation(floorId) + 0.1;
            
            const pathPoints = newPathWaypoints.map(wp => ({ x: wp.x, z: wp.z }));
            let linePoints = [];
            
            for (let i = 0; i < newPathWaypoints.length - 1; i++) {
                const startPoint = new THREE.Vector3(newPathWaypoints[i].x, y, newPathWaypoints[i].z);
                const endPoint = new THREE.Vector3(newPathWaypoints[i + 1].x, y, newPathWaypoints[i + 1].z);
                const segmentType = newPathSegmentTypes[i] || newPathType;
                
                if (segmentType === 'linear') {
                    if (i === 0 || linePoints.length === 0) {
                        linePoints.push(startPoint);
                    }
                    linePoints.push(endPoint);
                } else {
                    const controlPoints = newPathControlPoints[i];
                    if (controlPoints && controlPoints.cp1 && controlPoints.cp2) {
                        const cp1 = new THREE.Vector3(controlPoints.cp1.x, y, controlPoints.cp1.z);
                        const cp2 = new THREE.Vector3(controlPoints.cp2.x, y, controlPoints.cp2.z);
                        
                        // Tạo Cubic Bezier Curve
                        const bezierCurve = new THREE.CubicBezierCurve3(startPoint, cp1, cp2, endPoint);
                        const divisions = 30; // Số điểm cho mỗi segment bezier
                        const segmentPoints = bezierCurve.getPoints(divisions);
                        
                        if (i === 0 || linePoints.length === 0) {
                            linePoints.push(segmentPoints[0]);
                        }
                        // Bỏ điểm đầu để tránh trùng lặp
                        for (let j = 1; j < segmentPoints.length; j++) {
                            linePoints.push(segmentPoints[j]);
                        }
                    } else {
                        // Fallback: nếu không có control points, dùng cách cũ
                        const midPoint = new THREE.Vector3().lerpVectors(startPoint, endPoint, 0.5);
                        const dir = new THREE.Vector3().subVectors(endPoint, startPoint);
                        const perp = new THREE.Vector3(-dir.z, 0, dir.x).normalize();
                        const curveAmount = dir.length() * 0.3;
                        midPoint.add(perp.multiplyScalar(curveAmount));
                        
                        const bezierCurve = new THREE.CatmullRomCurve3([startPoint, midPoint, endPoint], false);
                        const divisions = 20;
                        const segmentPoints = bezierCurve.getPoints(divisions);
                        
                        if (i === 0 || linePoints.length === 0) {
                            linePoints.push(segmentPoints[0]);
                        }
                        for (let j = 1; j < segmentPoints.length; j++) {
                            linePoints.push(segmentPoints[j]);
                        }
                    }
                }
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ff00,
                linewidth: 3,
                opacity: 0.8,
                transparent: true,
                linecap: 'round'
            });
            newPathPreview = new THREE.Line(geometry, material);
            scene.add(newPathPreview);
        }
        
        // Xử lý click để thêm waypoint (sẽ được gọi từ raycaster)
        function handlePathCreationClick(intersectPoint) {
            if (!isCreatingPath) return;
            
            // Chuyển điểm intersect thành Vector3 với y = 0
            const waypoint = new THREE.Vector3(intersectPoint.x, 0, intersectPoint.z);
            addWaypointToNewPath(waypoint);
        }

        // Function to create linear curve (đường thẳng nối các điểm)
        function createLinearCurve(path, closed = true, elevation = 0.1) {
            const points = path.map(p => new THREE.Vector3(p.x, elevation, p.z));
            
            if (points.length < 2) {
                points.push(new THREE.Vector3(points[0].x + 1, elevation, points[0].z + 1));
            }
            
            // Tạo curve từ các điểm, nối thẳng
            if (closed && points.length > 2) {
                // Thêm điểm đầu vào cuối để đóng vòng
                points.push(points[0].clone());
            }
            
            return new THREE.CatmullRomCurve3(points, false); // false vì đã tự đóng bằng cách thêm điểm
        }
        
        // Function to create bezier/spline curve from path points
        function createSplineCurve(path, closed = true, elevation = 0.1) {
            const points = path.map(p => new THREE.Vector3(p.x, elevation, p.z));
            
            // Nếu path có ít hơn 2 điểm, không thể tạo curve
            if (points.length < 2) {
                // Tạo một điểm giả để tránh lỗi
                points.push(new THREE.Vector3(points[0].x + 1, elevation, points[0].z + 1));
            }
            
            // Nếu path có ít hơn 4 điểm và closed, cần thêm điểm để spline hoạt động tốt
            if (points.length < 4 && closed) {
                const extendedPoints = [...points];
                if (points.length === 2) {
                    // Thêm 2 điểm giữa để tạo đường cong mượt
                    const mid1 = new THREE.Vector3().lerpVectors(points[0], points[1], 0.33);
                    const mid2 = new THREE.Vector3().lerpVectors(points[0], points[1], 0.67);
                    extendedPoints.splice(1, 0, mid1, mid2);
                } else if (points.length === 3) {
                    // Thêm 1 điểm giữa điểm đầu và cuối
                    const mid = new THREE.Vector3().lerpVectors(points[0], points[2], 0.5);
                    extendedPoints.push(mid);
                }
                return new THREE.CatmullRomCurve3(extendedPoints, closed);
            }
            
            // Nếu không đóng và có ít hơn 2 điểm, không thể tạo spline
            if (!closed && points.length < 2) {
                points.push(new THREE.Vector3(points[0].x + 1, elevation, points[0].z + 1));
            }
            
            return new THREE.CatmullRomCurve3(points, closed);
        }
        
        // Function to create curve from path object với segmentTypes
        function createCurveFromPath(pathObj, closed = true, elevation = 0.1) {
            if (typeof pathObj === 'object' && pathObj.points) {
                const points = pathObj.points;
                const segmentTypes = pathObj.segmentTypes;
                const y = (elevation !== undefined) ? elevation : getPathElevation(pathObj);
                
                // Nếu có segmentTypes, tạo CurvePath với nhiều segment
                if (segmentTypes && segmentTypes.length > 0) {
                    const curvePath = new THREE.CurvePath();
                    
                    for (let i = 0; i < points.length - 1; i++) {
                        const startPoint = new THREE.Vector3(points[i].x, y, points[i].z);
                        const endPoint = new THREE.Vector3(points[i + 1].x, y, points[i + 1].z);
                        const segmentType = segmentTypes[i] || 'linear';
                        
                        if (segmentType === 'linear') {
                            // Tạo đường thẳng bằng QuadraticBezierCurve3 với control point ở giữa
                            const midPoint = new THREE.Vector3().lerpVectors(startPoint, endPoint, 0.5);
                            const lineCurve = new THREE.QuadraticBezierCurve3(startPoint, midPoint, endPoint);
                            curvePath.add(lineCurve);
                        } else {
                            // Tạo bezier curve với control points
                            const controlPoints = pathObj.controlPoints;
                            if (controlPoints && controlPoints[i] && controlPoints[i].cp1 && controlPoints[i].cp2) {
                                // Sử dụng control points đã lưu
                                const cp1 = new THREE.Vector3(controlPoints[i].cp1.x, y, controlPoints[i].cp1.z);
                                const cp2 = new THREE.Vector3(controlPoints[i].cp2.x, y, controlPoints[i].cp2.z);
                                const bezierCurve = new THREE.CubicBezierCurve3(startPoint, cp1, cp2, endPoint);
                                curvePath.add(bezierCurve);
                            } else {
                                // Fallback: tạo control points tự động
                                const midPoint = new THREE.Vector3().lerpVectors(startPoint, endPoint, 0.5);
                                const dir = new THREE.Vector3().subVectors(endPoint, startPoint);
                                const perp = new THREE.Vector3(-dir.z, 0, dir.x).normalize();
                                const curveAmount = dir.length() * 0.3;
                                midPoint.add(perp.multiplyScalar(curveAmount));
                                
                                const bezierCurve = new THREE.CatmullRomCurve3([startPoint, midPoint, endPoint], false);
                                curvePath.add(bezierCurve);
                            }
                        }
                    }
                    
                    // Nếu đóng, thêm segment từ điểm cuối về điểm đầu
                    if (closed && points.length > 2) {
                        const lastIndex = points.length - 1;
                        const startPoint = new THREE.Vector3(points[lastIndex].x, y, points[lastIndex].z);
                        const endPoint = new THREE.Vector3(points[0].x, y, points[0].z);
                        const segmentType = segmentTypes[lastIndex] || segmentTypes[0] || 'linear';
                        
                        if (segmentType === 'linear') {
                            const midPoint = new THREE.Vector3().lerpVectors(startPoint, endPoint, 0.5);
                            const lineCurve = new THREE.QuadraticBezierCurve3(startPoint, midPoint, endPoint);
                            curvePath.add(lineCurve);
                        } else {
                            // Bezier với control points
                            const controlPoints = pathObj.controlPoints;
                            if (controlPoints && controlPoints[lastIndex] && controlPoints[lastIndex].cp1 && controlPoints[lastIndex].cp2) {
                                const cp1 = new THREE.Vector3(controlPoints[lastIndex].cp1.x, y, controlPoints[lastIndex].cp1.z);
                                const cp2 = new THREE.Vector3(controlPoints[lastIndex].cp2.x, y, controlPoints[lastIndex].cp2.z);
                                const bezierCurve = new THREE.CubicBezierCurve3(startPoint, cp1, cp2, endPoint);
                                curvePath.add(bezierCurve);
                            } else {
                                const midPoint = new THREE.Vector3().lerpVectors(startPoint, endPoint, 0.5);
                                const dir = new THREE.Vector3().subVectors(endPoint, startPoint);
                                const perp = new THREE.Vector3(-dir.z, 0, dir.x).normalize();
                                const curveAmount = dir.length() * 0.3;
                                midPoint.add(perp.multiplyScalar(curveAmount));
                                const bezierCurve = new THREE.CatmullRomCurve3([startPoint, midPoint, endPoint], false);
                                curvePath.add(bezierCurve);
                            }
                        }
                    }
                    
                    return curvePath;
                }
                
                // Backward compatibility: nếu có type cũ
                if (pathObj.type === 'linear') {
                    return createLinearCurve(pathObj.points, closed, y);
                } else {
                    return createSplineCurve(pathObj.points, closed, y);
                }
            } else {
                // Path là mảng points cũ (backward compatibility)
                return createSplineCurve(pathObj, closed, elevation);
            }
        }

        // Function to create path visualization
        function createPathLine(pathObj, color, elevation) {
            // Xử lý path object hoặc mảng points cũ
            let pathPoints, segmentTypes;
            if (typeof pathObj === 'object' && pathObj.points) {
                pathPoints = pathObj.points;
                segmentTypes = pathObj.segmentTypes;
            } else {
                // Backward compatibility với mảng points cũ
                pathPoints = pathObj;
                segmentTypes = null;
            }
            const y = (elevation !== undefined) ? elevation : getPathElevation(pathObj);
            
            // Tạo curve dựa trên type
            const curve = createCurveFromPath(pathObj, true, y);
            
            // Tạo điểm để vẽ
            let linePoints;
            if (segmentTypes && segmentTypes.length > 0) {
                // Có segmentTypes: vẽ từng segment riêng biệt
                linePoints = [];
                const closed = pathPoints.length > 2;
                const segments = closed ? pathPoints.length : pathPoints.length - 1;
                
                for (let i = 0; i < segments; i++) {
                    const startIdx = i;
                    const endIdx = (i + 1) % pathPoints.length;
                    const segmentType = segmentTypes[i] || 'linear';
                    
                    const startPoint = new THREE.Vector3(pathPoints[startIdx].x, y, pathPoints[startIdx].z);
                    const endPoint = new THREE.Vector3(pathPoints[endIdx].x, y, pathPoints[endIdx].z);
                    
                    if (segmentType === 'linear') {
                        // Đường thẳng: chỉ cần 2 điểm
                        if (i === 0 || linePoints.length === 0) {
                            linePoints.push(startPoint);
                        }
                        linePoints.push(endPoint);
                    } else {
                        // Bezier: sử dụng control points nếu có
                        const controlPoints = pathObj.controlPoints;
                        let bezierCurve;
                        
                        if (controlPoints && controlPoints[i] && controlPoints[i].cp1 && controlPoints[i].cp2) {
                            // Sử dụng control points đã lưu
                            const cp1 = new THREE.Vector3(controlPoints[i].cp1.x, y, controlPoints[i].cp1.z);
                            const cp2 = new THREE.Vector3(controlPoints[i].cp2.x, y, controlPoints[i].cp2.z);
                            bezierCurve = new THREE.CubicBezierCurve3(startPoint, cp1, cp2, endPoint);
                        } else {
                            // Fallback: tạo control points tự động
                            const midPoint = new THREE.Vector3().lerpVectors(startPoint, endPoint, 0.5);
                            const dir = new THREE.Vector3().subVectors(endPoint, startPoint);
                            const perp = new THREE.Vector3(-dir.z, 0, dir.x).normalize();
                            const curveAmount = dir.length() * 0.3;
                            midPoint.add(perp.multiplyScalar(curveAmount));
                            bezierCurve = new THREE.CatmullRomCurve3([startPoint, midPoint, endPoint], false);
                        }
                        
                        const divisions = 30; // Số điểm cho mỗi segment bezier
                        const segmentPoints = bezierCurve.getPoints(divisions);
                        
                        if (i === 0 || linePoints.length === 0) {
                            linePoints.push(segmentPoints[0]);
                        }
                        // Bỏ điểm đầu để tránh trùng lặp
                        for (let j = 1; j < segmentPoints.length; j++) {
                            linePoints.push(segmentPoints[j]);
                        }
                    }
                }
            } else {
                // Không có segmentTypes: xử lý như cũ
                const pathType = (typeof pathObj === 'object' && pathObj.type) ? pathObj.type : 'bezier';
                if (pathType === 'linear') {
                    linePoints = pathPoints.map(p => new THREE.Vector3(p.x, y, p.z));
                    if (pathPoints.length > 2) {
                        linePoints.push(linePoints[0].clone());
                    }
                } else {
                    const divisions = pathPoints.length * 50;
                    linePoints = curve.getPoints(divisions);
                }
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
            const material = new THREE.LineBasicMaterial({ 
                color: color,
                linewidth: 2,
                opacity: 0.5,
                transparent: true,
                linecap: 'round'
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            // Create waypoint markers
            const markers = new THREE.Group();
            pathPoints.forEach((point, index) => {
                const markerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
                const markerMaterial = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(point.x, y, point.z);
                marker.rotation.x = -Math.PI / 2;
                markers.add(marker);
                
                // Add number label (simple sphere for now)
                const labelGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const labelMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                label.position.set(point.x, 0.5, point.z);
                markers.add(label);
            });
            scene.add(markers);
            
            return { line, markers, curve };
        }

        // AGV class
        class AGV {
            constructor(id, path, color = 0x4CAF50) {
                this.id = id;
                this.color = color;
                
                // Path object (để lấy floorId, elevation)
                const pathObj = typeof path === 'object' && path.points ? path : { points: path, type: 'bezier' };
                this.pathObj = pathObj;
                if (typeof path === 'object' && path.points) {
                    this.path = path.points;
                    this.pathType = path.type || 'bezier';
                } else {
                    this.path = path;
                    this.pathType = 'bezier';
                }
                
                this.currentFloorId = pathObj.floorId || 'F1';
                const pathElevation = getPathElevation(pathObj);
                const floorElevation = getFloorElevation(this.currentFloorId);
                
                this.loopPath = true; // Lặp lại path khi đến cuối
                
                // Tạo curve từ path với elevation đúng tầng
                this.curve = createCurveFromPath(pathObj, true, pathElevation);
                
                // Vị trí trên curve (0.0 đến 1.0)
                this.curvePosition = Math.random();
                
                this.speed = 0.0005 + Math.random() * 0.001;
                
                const startPos = this.curve.getPointAt(0);
                this.currentX = startPos.x;
                this.currentZ = startPos.z;
                
                this.rotationY = 0;
                this.state = 'MOVING'; // MOVING | ENTERING_ELEVATOR | IN_ELEVATOR | EXITING_ELEVATOR | IDLE
                this.battery = Math.random() * 30 + 70;
                this.loaded = Math.random() > 0.5;
                // Elevator state
                this.elevatorTargetX = 0;
                this.elevatorTargetZ = 0;
                this.nextFloorPathIndex = null;
                this.nextFloorId = null;
                this.elevatorTweenProgress = 0;
                this.elevatorFromY = 0;
                this.elevatorToY = 0;
                this.visitedEndpointIds = new Set();

                this.group = new THREE.Group();
                this.importedModel = null;
                this.defaultModelGroup = new THREE.Group();
                this.isUsingDefaultModel = true;
                this.isBeingDragged = false;
                this.rotationOffset = 0;

                // Body
                const bodyGeometry = new THREE.BoxGeometry(2, 1, 3);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: this.color,
                    roughness: 0.5,
                    metalness: 0.3
                });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.castShadow = true;
                this.body.receiveShadow = true;
                this.body.position.y = 0.5;
                this.defaultModelGroup.add(this.body);

                const indicatorGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
                const indicatorMaterial = new THREE.MeshStandardMaterial({
                    color: this.loaded ? 0xff6b00 : 0x00ff00,
                    emissive: this.loaded ? 0xff6b00 : 0x00ff00,
                    emissiveIntensity: 0.5
                });
                this.indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                this.indicator.position.y = 1.2;
                this.defaultModelGroup.add(this.indicator);

                const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const wheelPositions = [
                    { x: 0.8, z: 1.2 },
                    { x: -0.8, z: 1.2 },
                    { x: 0.8, z: -1.2 },
                    { x: -0.8, z: -1.2 }
                ];
                this.wheels = [];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(pos.x, 0.2, pos.z);
                    wheel.castShadow = true;
                    this.defaultModelGroup.add(wheel);
                    this.wheels.push(wheel);
                });

                const arrowGeometry = new THREE.ConeGeometry(0.2, 0.8, 8);
                const arrowMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
                this.arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                this.arrow.position.set(0, 0.6, 1.5);
                this.arrow.rotation.x = -Math.PI / 2;
                this.defaultModelGroup.add(this.arrow);
                
                this.group.add(this.defaultModelGroup);

                // Vị trí ban đầu: x,z từ curve, y = elevation tầng (AGV đứng trên sàn)
                this.group.position.set(this.currentX, floorElevation, this.currentZ);

                scene.add(this.group);

                // Path visualization theo elevation tầng
                const pathVisual = createPathLine(pathObj, this.color, pathElevation);
                this.pathLine = pathVisual.line;
                this.pathMarkers = pathVisual.markers;
                this.showPath = true;
            }

            update() {
                if (this.isBeingDragged) {
                    this.currentX = this.group.position.x;
                    this.currentZ = this.group.position.z;
                    this.rotationY = this.group.rotation.y;
                    return;
                }

                const floorY = getFloorElevation(this.currentFloorId);
                const moveSpeed = 0.15;
                const elevatorArrivalDist = 1.5;
                const elevatorYStep = 0.08;

                if (this.state === 'ENTERING_ELEVATOR') {
                    const dx = this.elevatorTargetX - this.group.position.x;
                    const dz = this.elevatorTargetZ - this.group.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < elevatorArrivalDist) {
                        this.state = 'IN_ELEVATOR';
                        this.elevatorTweenProgress = 0;
                        this.elevatorFromY = getFloorElevation(this.currentFloorId);
                        this.elevatorToY = getFloorElevation(this.nextFloorId);
                    } else {
                        const nx = this.group.position.x + (dx / dist) * moveSpeed;
                        const nz = this.group.position.z + (dz / dist) * moveSpeed;
                        this.group.position.set(nx, floorY, nz);
                        this.currentX = nx;
                        this.currentZ = nz;
                    }
                    this.group.rotation.y = this.rotationY;
                    return;
                }

                if (this.state === 'IN_ELEVATOR') {
                    this.elevatorTweenProgress += 0.015;
                    if (this.elevatorTweenProgress >= 1) {
                        this.currentFloorId = this.nextFloorId;
                        this.state = 'EXITING_ELEVATOR';
                    } else {
                        const y = this.elevatorFromY + (this.elevatorToY - this.elevatorFromY) * this.elevatorTweenProgress;
                        this.group.position.set(this.elevatorTargetX, y, this.elevatorTargetZ);
                    }
                    return;
                }

                if (this.state === 'EXITING_ELEVATOR') {
                    const nextPath = pathDefinitions[this.nextFloorPathIndex];
                    if (!nextPath) {
                        this.state = 'MOVING';
                        return;
                    }
                    this.pathObj = nextPath;
                    this.path = nextPath.points;
                    this.currentFloorId = nextPath.floorId || 'F1';
                    const pathElevation = getPathElevation(nextPath);
                    this.curve = createCurveFromPath(nextPath, true, pathElevation);
                    this.curvePosition = 0;
                    if (this.pathLine) {
                        scene.remove(this.pathLine);
                        this.pathLine.geometry.dispose();
                        this.pathLine.material.dispose();
                    }
                    if (this.pathMarkers) {
                        scene.remove(this.pathMarkers);
                        this.pathMarkers.traverse(c => {
                            if (c.geometry) c.geometry.dispose();
                            if (c.material) c.material.dispose();
                        });
                    }
                    const pathVisual = createPathLine(nextPath, this.color, pathElevation);
                    this.pathLine = pathVisual.line;
                    this.pathMarkers = pathVisual.markers;
                    this.pathLine.visible = this.showPath;
                    this.pathMarkers.visible = this.showPath;
                    this.state = 'MOVING';
                    return;
                }

                // MOVING
                this.curvePosition += this.speed;

                if (this.curvePosition >= 1.0) {
                    const pathObj = this.pathObj;
                    const hasElevator = pathObj && pathObj.elevatorExitAtEnd && pathObj.nextFloorPathIndex != null && pathDefinitions[pathObj.nextFloorPathIndex];
                    if (hasElevator) {
                        const nextPath = pathDefinitions[pathObj.nextFloorPathIndex];
                        const nextFloorId = nextPath.floorId || 'F1';
                        const elevator = elevators.find(e => e.floorIds.includes(this.currentFloorId) && e.floorIds.includes(nextFloorId));
                        if (elevator && elevator.positions[this.currentFloorId]) {
                            const pos = elevator.positions[this.currentFloorId];
                            this.elevatorTargetX = pos.x;
                            this.elevatorTargetZ = pos.z;
                            this.nextFloorPathIndex = pathObj.nextFloorPathIndex;
                            this.nextFloorId = nextFloorId;
                            this.state = 'ENTERING_ELEVATOR';
                            return;
                        }
                    }
                    if (this.loopPath) {
                        this.curvePosition = this.curvePosition % 1.0;
                    } else {
                        this.curvePosition = 1.0;
                        this.state = 'IDLE';
                        return;
                    }
                }

                const currentPos = this.curve.getPointAt(this.curvePosition);
                this.currentX = currentPos.x;
                this.currentZ = currentPos.z;
                const tangent = this.curve.getTangentAt(this.curvePosition);
                const pathRotation = Math.atan2(tangent.x, tangent.z);
                this.rotationY = pathRotation + this.rotationOffset;
                this.group.position.set(this.currentX, floorY, this.currentZ);
                this.group.rotation.y = this.rotationY;

                const wheelSpeed = this.speed * 2000;
                this.wheels.forEach(wheel => { wheel.rotation.x += wheelSpeed; });
                this.battery -= 0.001;
                if (this.battery < 0) this.battery = 0;
                if (typeof endpoints !== 'undefined') {
                    const threshold = 4;
                    endpoints.forEach(ep => {
                        if (ep.floorId !== this.currentFloorId || this.visitedEndpointIds.has(ep.id)) return;
                        const pos = getEndpointPosition(ep);
                        const dx = this.group.position.x - pos.x, dz = this.group.position.z - pos.z;
                        if (dx * dx + dz * dz < threshold * threshold) {
                            this.visitedEndpointIds.add(ep.id);
                            if (typeof onEndpointReached === 'function') onEndpointReached(this.id, ep.id);
                        }
                    });
                }
            }

            remove() {
                scene.remove(this.group);
                if (this.pathLine) {
                    scene.remove(this.pathLine);
                    this.pathLine.geometry.dispose();
                    this.pathLine.material.dispose();
                }
                if (this.pathMarkers) {
                    scene.remove(this.pathMarkers);
                    this.pathMarkers.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
                this.group.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }

            togglePathVisibility() {
                this.showPath = !this.showPath;
                if (this.pathLine) {
                    this.pathLine.visible = this.showPath;
                }
                if (this.pathMarkers) {
                    this.pathMarkers.visible = this.showPath;
                }
            }
            
            // Import model từ file để thay thế mô hình mặc định
            importModel(object) {
                if (!object) return;
                
                // Xóa model cũ nếu có
                if (this.importedModel) {
                    this.group.remove(this.importedModel);
                    this.importedModel.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }
                
                // Ẩn default model
                this.defaultModelGroup.visible = false;
                this.isUsingDefaultModel = false;
                
                // Xử lý object mới
                object.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // Tính toán bounding box ban đầu để scale
                let box = new THREE.Box3().setFromObject(object);
                let size = box.getSize(new THREE.Vector3());
                
                // Scale nếu cần (trước khi center)
                const maxDimension = Math.max(size.x, size.y, size.z);
                if (maxDimension > 5) {
                    const scale = 5 / maxDimension;
                    object.scale.set(scale, scale, scale);
                    // Tính lại bounding box sau khi scale
                    box = new THREE.Box3().setFromObject(object);
                    size = box.getSize(new THREE.Vector3());
                } else if (maxDimension < 0.5) {
                    const scale = 2 / maxDimension;
                    object.scale.set(scale, scale, scale);
                    // Tính lại bounding box sau khi scale
                    box = new THREE.Box3().setFromObject(object);
                    size = box.getSize(new THREE.Vector3());
                }
                
                // Center object theo X và Z
                const center = box.getCenter(new THREE.Vector3());
                object.position.x -= center.x;
                object.position.z -= center.z;
                
                // Đặt bottom trên floor (y = 0) - tính lại sau khi scale
                const minY = box.min.y;
                object.position.y -= minY;
                
                // Verify: Tính lại bounding box sau khi di chuyển để đảm bảo bottom ở y = 0
                box = new THREE.Box3().setFromObject(object);
                if (Math.abs(box.min.y) > 0.01) {
                    // Nếu bottom không ở y = 0, điều chỉnh lại
                    object.position.y -= box.min.y;
                }
                
                // Thêm vào group
                this.importedModel = object;
                this.group.add(this.importedModel);
            }
            
            // Remove imported model và quay về default
            removeModel() {
                if (this.importedModel) {
                    this.group.remove(this.importedModel);
                    this.importedModel.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    this.importedModel = null;
                }
                
                // Hiện lại default model
                this.defaultModelGroup.visible = true;
                this.isUsingDefaultModel = true;
            }
        }

        // AGV array
        let agvs = [];
        let animationPaused = false;
        
        // Stats.js cho FPS counter với fallback
        let stats = null;
        if (typeof Stats !== 'undefined') {
            stats = new Stats();
            stats.showPanel(0);
            stats.dom.style.position = 'absolute';
            stats.dom.style.top = '8px';
            stats.dom.style.left = '8px';
            stats.dom.style.zIndex = '10';
            const mainEl = document.querySelector('.main');
            if (mainEl) mainEl.appendChild(stats.dom); else document.body.appendChild(stats.dom);
        } else {
            console.warn('Stats.js không khả dụng. FPS counter sẽ không hiển thị.');
            // Tạo fake stats object để tránh lỗi
            stats = {
                begin: () => {},
                end: () => {}
            };
        }
        
        let gui = null; // Không dùng dat.GUI nữa; giữ biến cho tương thích
        
        // Hàm import model từ file cho AGV
        function importAGVModelFromFile(agv, file) {
            const fileName = file.name.toLowerCase();
            const fileExtension = fileName.split('.').pop();
            
            console.log('Bắt đầu import model cho AGV:', agv.id, 'File:', file.name);
            
            // Kiểm tra loaders
            const loadersAvailable = {
                gltf: typeof THREE.GLTFLoader !== 'undefined',
                obj: typeof THREE.OBJLoader !== 'undefined',
                fbx: typeof THREE.FBXLoader !== 'undefined'
            };
            
            // Hàm xử lý sau khi load
            const onLoad = (object) => {
                if (!object) {
                    alert('Không thể load model từ file: ' + file.name);
                    return;
                }
                agv.importModel(object);
                config.hasImportedModel = !agv.isUsingDefaultModel;
                // Cập nhật agvInfo cho dat.GUI
                if (typeof agvInfo !== 'undefined') {
                    agvInfo.hasImportedModel = !agv.isUsingDefaultModel;
                }
                console.log('Đã import model thành công cho AGV:', agv.id);
                alert('Đã import model thành công cho AGV: ' + agv.id);
            };
            
            // Hàm xử lý lỗi
            const onError = (error) => {
                console.error('Lỗi khi import model cho AGV:', error);
                const errorMsg = error && error.message ? error.message : String(error);
                alert('Lỗi khi import model: ' + file.name + '\n' + errorMsg);
            };
            
            // Load file dựa trên extension
            const fileURL = URL.createObjectURL(file);
            
            try {
                if (fileExtension === 'gltf' || fileExtension === 'glb') {
                    if (!loadersAvailable.gltf) {
                        URL.revokeObjectURL(fileURL);
                        alert('GLTFLoader chưa được load. Vui lòng kiểm tra lại CDN link.');
                        return;
                    }
                    const loader = new THREE.GLTFLoader();
                    loader.load(
                        fileURL,
                        (gltf) => {
                            URL.revokeObjectURL(fileURL);
                            if (gltf && gltf.scene) {
                                onLoad(gltf.scene);
                            } else {
                                onError(new Error('GLTF scene không hợp lệ'));
                            }
                        },
                        (progress) => {
                            if (progress.lengthComputable) {
                                const percent = (progress.loaded / progress.total) * 100;
                                console.log('Loading progress:', percent.toFixed(2) + '%');
                            }
                        },
                        (error) => {
                            URL.revokeObjectURL(fileURL);
                            onError(error);
                        }
                    );
                } else if (fileExtension === 'obj') {
                    if (!loadersAvailable.obj) {
                        URL.revokeObjectURL(fileURL);
                        alert('OBJLoader chưa được load. Vui lòng kiểm tra lại CDN link.');
                        return;
                    }
                    const loader = new THREE.OBJLoader();
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const object = loader.parse(e.target.result);
                            URL.revokeObjectURL(fileURL);
                            onLoad(object);
                        } catch (err) {
                            URL.revokeObjectURL(fileURL);
                            onError(err);
                        }
                    };
                    reader.onerror = (err) => {
                        URL.revokeObjectURL(fileURL);
                        onError(new Error('Lỗi khi đọc file OBJ: ' + err));
                    };
                    reader.readAsText(file);
                } else if (fileExtension === 'fbx') {
                    if (!loadersAvailable.fbx) {
                        URL.revokeObjectURL(fileURL);
                        alert('FBXLoader chưa được load. Vui lòng kiểm tra lại CDN link.');
                        return;
                    }
                    const loader = new THREE.FBXLoader();
                    loader.load(
                        fileURL,
                        (object) => {
                            URL.revokeObjectURL(fileURL);
                            onLoad(object);
                        },
                        (progress) => {
                            if (progress.lengthComputable) {
                                const percent = (progress.loaded / progress.total) * 100;
                                console.log('Loading progress:', percent.toFixed(2) + '%');
                            }
                        },
                        (error) => {
                            URL.revokeObjectURL(fileURL);
                            onError(error);
                        }
                    );
                } else {
                    URL.revokeObjectURL(fileURL);
                    alert('Định dạng file không được hỗ trợ: .' + fileExtension + '\nHỗ trợ: .gltf, .glb, .obj, .fbx');
                    return;
                }
            } catch (err) {
                URL.revokeObjectURL(fileURL);
                onError(err);
            }
        }
        
        const config = {
            animation: true,
            showPaths: true,
            cameraType: 'Orthographic',
            selectedPathIndex: 0,
            selectedPathName: pathNames[0] || '',
            currentFloorId: building.floors[0].id, // Tầng khi tạo path mới
            isCreatingPath: false,
            newPathType: 'bezier',
            agvSpeed: 1.0,
            addAGV: () => {
                if (config.selectedPathIndex !== undefined && config.selectedPathIndex >= 0 && config.selectedPathIndex < pathDefinitions.length) {
                    addAGVWithSelectedPath(config.selectedPathIndex);
                } else {
                    alert('Vui lòng chọn path trước khi thêm AGV!');
                    console.warn('Vui lòng chọn path trước khi thêm AGV. Path index:', config.selectedPathIndex);
                }
            },
            resetCamera: () => resetCamera(),
            // Controls cho AGV model
            selectedAGVId: 'Chưa chọn AGV', // ID của AGV đã chọn
            hasImportedModel: false, // AGV đã chọn có model import không
            importAGVModel: () => {
                if (!selectedAGV) {
                    alert('Vui lòng chọn một AGV trước!');
                    return;
                }
                // Tạo file input element
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.gltf,.glb,.obj,.fbx';
                input.style.display = 'none';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        importAGVModelFromFile(selectedAGV, file);
                    }
                    document.body.removeChild(input);
                };
                document.body.appendChild(input);
                input.click();
            },
            removeAGVModel: () => {
                if (!selectedAGV) {
                    alert('Vui lòng chọn một AGV trước!');
                    return;
                }
                if (selectedAGV.isUsingDefaultModel) {
                    alert('AGV này đang sử dụng mô hình mặc định!');
                    return;
                }
                selectedAGV.removeModel();
                config.hasImportedModel = false;
                // Cập nhật agvInfo cho dat.GUI
                if (typeof agvInfo !== 'undefined') {
                    agvInfo.hasImportedModel = false;
                }
            },
            // Controls cho khối
            addBlock: () => {
                const x = (Math.random() - 0.5) * 50;
                const z = (Math.random() - 0.5) * 50;
                const size = [2 + Math.random() * 3, 2 + Math.random() * 3, 2 + Math.random() * 3];
                const colors = [0x888888, 0x666666, 0x444444, 0x999999];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const block = createBlock([x, size[1] / 2, z], size, color);
                selectBlock(block);
            },
            deleteSelectedBlock: () => {
                if (selectedBlock) {
                    deleteBlock(selectedBlock);
                }
            },
            clearAllBlocks: () => clearAllBlocks(),
            transformMode: 'translate', // 'translate', 'rotate', 'scale'
            blockCount: () => blocks.length,
            importObject: () => {
                // Tạo file input element
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.gltf,.glb,.obj,.fbx';
                input.style.display = 'none';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const x = (Math.random() - 0.5) * 50;
                        const z = (Math.random() - 0.5) * 50;
                        importObject(file, [x, 0, z]);
                    }
                    // Xóa input sau khi sử dụng
                    document.body.removeChild(input);
                };
                document.body.appendChild(input);
                input.click();
            }
        };
        
        // Studio: đồng bộ path options với path đã chọn
        const studioPathOptions = { elevatorExitAtEnd: false, nextFloorPathIndex: 0 };
        function syncStudioPathOptions() {
            const p = pathDefinitions[config.selectedPathIndex];
            if (p) {
                studioPathOptions.elevatorExitAtEnd = !!p.elevatorExitAtEnd;
                studioPathOptions.nextFloorPathIndex = p.nextFloorPathIndex != null ? p.nextFloorPathIndex : 0;
            }
        }
        function applyStudioPathOptions() {
            const p = pathDefinitions[config.selectedPathIndex];
            if (p) {
                p.elevatorExitAtEnd = studioPathOptions.elevatorExitAtEnd;
                p.nextFloorPathIndex = studioPathOptions.nextFloorPathIndex;
            }
        }
        
        // Giao diện desktop: sidebar với panel cấu hình
        function refreshDesktopUI() {
            const pathSelect = document.getElementById('desktopPathSelect');
            if (pathSelect) {
                const cur = pathSelect.value;
                pathSelect.innerHTML = pathNames.map((name, i) => '<option value="' + i + '">' + (name || 'Path ' + (i + 1)) + '</option>').join('') || '<option value="">-- Chưa có path --</option>';
                pathSelect.value = (config.selectedPathIndex >= 0 && config.selectedPathIndex < pathNames.length) ? config.selectedPathIndex : '';
            }
            const floorSelect = document.getElementById('desktopFloorSelect');
            if (floorSelect) {
                floorSelect.innerHTML = building.floors.map(f => '<option value="' + f.id + '">' + f.name + '</option>').join('');
                floorSelect.value = config.currentFloorId || (building.floors[0] && building.floors[0].id);
            }
            const agvInfoEl = document.getElementById('desktopAgvInfo');
            if (agvInfoEl) agvInfoEl.textContent = agvInfo.selectedAGVId || 'Chưa chọn AGV';
            const pathCountEl = document.getElementById('statusPath');
            if (pathCountEl) pathCountEl.textContent = 'Path: ' + pathNames.length;
            const floorCountEl = document.getElementById('statusFloor');
            if (floorCountEl) floorCountEl.textContent = 'Tầng: ' + building.floors.length;
            syncStudioPathOptions();
            const elevatorCb = document.getElementById('desktopElevatorExit');
            const nextIdx = document.getElementById('desktopNextPathIndex');
            if (elevatorCb) elevatorCb.checked = studioPathOptions.elevatorExitAtEnd;
            if (nextIdx) { nextIdx.value = studioPathOptions.nextFloorPathIndex; nextIdx.max = Math.max(0, pathDefinitions.length - 1); }
        }
        function initDesktopUI() {
            const sidebar = document.getElementById('sidebarContent');
            if (!sidebar) return;
            sidebar.innerHTML = `
                <div class="panel open" data-panel="view">
                    <div class="panel-header">Xem 3D</div>
                    <div class="panel-body">
                        <div class="form-row checkbox-row"><label><input type="checkbox" id="desktopAnimation" checked /> Animation</label></div>
                        <div class="form-row checkbox-row"><label><input type="checkbox" id="desktopShowPaths" checked /> Hiện path</label></div>
                        <div class="form-row"><label class="form-label">Camera</label><select id="desktopCamera"><option value="Orthographic">Orthographic</option><option value="Perspective">Perspective</option></select></div>
                        <div class="form-row"><button class="btn btn-secondary" id="desktopResetCam">Reset camera</button></div>
                    </div>
                </div>
                <div class="panel open" data-panel="path">
                    <div class="panel-header">Path</div>
                    <div class="panel-body">
                        <div class="form-row"><label class="form-label">Chọn path</label><select id="desktopPathSelect"></select></div>
                        <div class="form-row"><label class="form-label">Tốc độ AGV</label><input type="range" id="desktopAgvSpeed" min="0.1" max="3" step="0.1" value="1" /><span id="desktopAgvSpeedVal">1</span></div>
                        <div class="form-row"><button class="btn btn-success" id="desktopAddAGV">Thêm AGV</button></div>
                    </div>
                </div>
                <div class="panel" data-panel="createpath">
                    <div class="panel-header">Tạo path mới</div>
                    <div class="panel-body">
                        <div class="form-row"><label class="form-label">Tầng</label><select id="desktopFloorSelect"></select></div>
                        <div class="form-row"><label class="form-label">Loại segment</label><select id="desktopPathType"><option value="linear">Thẳng</option><option value="bezier">Cong</option></select></div>
                        <div class="form-row"><button class="btn btn-secondary" id="desktopStartPath">Bắt đầu tạo path</button></div>
                        <div class="form-row"><button class="btn btn-success" id="desktopFinishPath">Hoàn thành</button><button class="btn btn-danger" id="desktopCancelPath">Hủy</button></div>
                        <div class="form-row"><span class="form-label">Waypoint: <span id="desktopWaypointCount">0</span></span></div>
                    </div>
                </div>
                <div class="panel" data-panel="agv">
                    <div class="panel-header">AGV</div>
                    <div class="panel-body">
                        <div class="form-row"><label class="form-label">AGV đã chọn</label><span id="desktopAgvInfo">Chưa chọn AGV</span></div>
                        <div class="form-row"><button class="btn btn-secondary" id="desktopImportAGVModel">Import model</button><button class="btn btn-danger" id="desktopRemoveAGVModel">Xóa model</button></div>
                    </div>
                </div>
                <div class="panel" data-panel="studio">
                    <div class="panel-header">Nhà xưởng &amp; Cấu hình</div>
                    <div class="panel-body">
                        <div class="form-row"><button class="btn btn-secondary" id="desktopAddFloor">Thêm tầng</button><button class="btn btn-danger" id="desktopRemoveFloor">Xóa tầng cuối</button></div>
                        <div class="form-row"><button class="btn btn-secondary" id="desktopApplyFloors">Áp dụng sàn/thang</button></div>
                        <div class="form-row checkbox-row"><label><input type="checkbox" id="desktopElevatorExit" /> Path: cuối = vào thang</label></div>
                        <div class="form-row"><label class="form-label">Path tầng tiếp (index)</label><input type="number" id="desktopNextPathIndex" min="0" value="0" style="width:100%;padding:6px;background:#3c3c3c;border:1px solid #555;color:#d4d4d4;" /></div>
                        <div class="form-row"><button class="btn btn-secondary" id="desktopAddEndpoint">Thêm endpoint</button> <span id="desktopEndpointCount">0</span></div>
                        <div class="form-row"><button class="btn btn-success" id="desktopSaveConfig">Lưu cấu hình</button><button class="btn btn-secondary" id="desktopLoadConfig">Tải cấu hình</button></div>
                    </div>
                </div>
                <div class="panel" data-panel="blocks">
                    <div class="panel-header">Khối / Đối tượng</div>
                    <div class="panel-body">
                        <div class="form-row"><button class="btn btn-secondary" id="desktopAddBlock">Tạo khối</button><button class="btn btn-secondary" id="desktopImportObject">Import 3D</button></div>
                        <div class="form-row"><button class="btn btn-danger" id="desktopDeleteBlock">Xóa đã chọn</button><button class="btn btn-danger" id="desktopClearBlocks">Xóa tất cả</button></div>
                        <div class="form-row"><label class="form-label">Chế độ</label><select id="desktopTransformMode"><option value="translate">Di chuyển</option><option value="rotate">Xoay</option><option value="scale">Tỷ lệ</option></select></div>
                        <div class="form-row"><span class="form-label">Số khối: <span id="desktopBlockCount">0</span></span></div>
                    </div>
                </div>
            `;
            sidebar.querySelectorAll('.panel-header').forEach(h => {
                h.addEventListener('click', () => {
                    const p = h.closest('.panel');
                    p.classList.toggle('open');
                });
            });
            document.getElementById('desktopAnimation').addEventListener('change', e => { animationPaused = !e.target.checked; });
            document.getElementById('desktopShowPaths').addEventListener('change', e => { togglePaths(e.target.checked); });
            document.getElementById('desktopCamera').addEventListener('change', e => {
                if ((e.target.value === 'Orthographic' && !isOrthographic) || (e.target.value === 'Perspective' && isOrthographic)) toggleCamera();
            });
            document.getElementById('desktopResetCam').addEventListener('click', () => resetCamera());
            document.getElementById('desktopPathSelect').addEventListener('change', e => {
                const i = parseInt(e.target.value, 10);
                if (!isNaN(i) && i >= 0 && i < pathNames.length) { config.selectedPathIndex = i; config.selectedPathName = pathNames[i]; refreshDesktopUI(); }
            });
            document.getElementById('desktopAgvSpeed').addEventListener('input', e => { config.agvSpeed = parseFloat(e.target.value); document.getElementById('desktopAgvSpeedVal').textContent = e.target.value; agvs.forEach(agv => agv.speed = config.agvSpeed * 0.0005); });
            document.getElementById('desktopAddAGV').addEventListener('click', () => config.addAGV());
            document.getElementById('desktopFloorSelect').addEventListener('change', e => { config.currentFloorId = e.target.value; if (isCreatingPath) updateNewPathPreview(); });
            document.getElementById('desktopPathType').addEventListener('change', e => { newPathType = e.target.value; config.newPathType = e.target.value; if (isCreatingPath && newPathWaypoints.length >= 2) updateNewPathPreview(); });
            document.getElementById('desktopStartPath').addEventListener('click', () => { config.isCreatingPath = true; newPathType = config.newPathType; startCreatingPath(); });
            document.getElementById('desktopFinishPath').addEventListener('click', () => finishCreatingPath());
            document.getElementById('desktopCancelPath').addEventListener('click', () => cancelCreatingPath());
            document.getElementById('desktopImportAGVModel').addEventListener('click', () => config.importAGVModel());
            document.getElementById('desktopRemoveAGVModel').addEventListener('click', () => config.removeAGVModel());
            document.getElementById('desktopAddFloor').addEventListener('click', () => {
                const n = building.floors.length + 1;
                building.floors.push({ id: 'F' + n, name: 'Tầng ' + n, elevation: 10 * (n - 1), width: 200, depth: 200 });
                rebuildFloorsAndElevators();
                refreshDesktopUI();
            });
            document.getElementById('desktopRemoveFloor').addEventListener('click', () => {
                if (building.floors.length <= 1) { alert('Cần ít nhất 1 tầng'); return; }
                const last = building.floors[building.floors.length - 1];
                if (pathDefinitions.some(p => p.floorId === last.id) || agvs.some(a => a.currentFloorId === last.id)) { alert('Tầng đang được path/AGV sử dụng'); return; }
                building.floors.pop();
                rebuildFloorsAndElevators();
                refreshDesktopUI();
            });
            document.getElementById('desktopApplyFloors').addEventListener('click', () => rebuildFloorsAndElevators());
            document.getElementById('desktopElevatorExit').addEventListener('change', e => { studioPathOptions.elevatorExitAtEnd = e.target.checked; applyStudioPathOptions(); });
            document.getElementById('desktopNextPathIndex').addEventListener('change', e => { studioPathOptions.nextFloorPathIndex = parseInt(e.target.value, 10) || 0; applyStudioPathOptions(); });
            document.getElementById('desktopAddEndpoint').addEventListener('click', () => addEndpoint({ type: 'standalone', x: 0, z: 0, floorId: building.floors[0] ? building.floors[0].id : 'F1' }));
            document.getElementById('desktopSaveConfig').addEventListener('click', () => saveStudioConfig());
            document.getElementById('desktopLoadConfig').addEventListener('click', () => { const input = document.createElement('input'); input.type = 'file'; input.accept = '.json'; input.onchange = (e) => { const f = e.target.files[0]; if (f) { const r = new FileReader(); r.onload = () => loadStudioConfig(r.result); r.readAsText(f); } }; input.click(); });
            document.getElementById('desktopAddBlock').addEventListener('click', () => config.addBlock());
            document.getElementById('desktopImportObject').addEventListener('click', () => config.importObject());
            document.getElementById('desktopDeleteBlock').addEventListener('click', () => config.deleteSelectedBlock());
            document.getElementById('desktopClearBlocks').addEventListener('click', () => config.clearAllBlocks());
            document.getElementById('desktopTransformMode').addEventListener('change', e => setTransformMode(e.target.value));
            syncStudioPathOptions();
            document.getElementById('desktopElevatorExit').checked = studioPathOptions.elevatorExitAtEnd;
            document.getElementById('desktopNextPathIndex').value = studioPathOptions.nextFloorPathIndex;
            refreshDesktopUI();
        }
        function tickDesktopUI() {
            const waypointEl = document.getElementById('desktopWaypointCount');
            if (waypointEl) waypointEl.textContent = newPathWaypoints.length;
            const blockEl = document.getElementById('desktopBlockCount');
            if (blockEl) blockEl.textContent = blocks.length;
            const endpointEl = document.getElementById('desktopEndpointCount');
            if (endpointEl) endpointEl.textContent = endpoints.length;
            const agvInfoEl = document.getElementById('desktopAgvInfo');
            if (agvInfoEl) agvInfoEl.textContent = agvInfo.selectedAGVId || 'Chưa chọn AGV';
        }
        initDesktopUI();

        // Không tạo AGV mặc định — người dùng thêm AGV sau khi đã tạo path

        // Labels for AGVs
        const labels = [];

        function updateLabels() {
            // Remove old labels
            labels.forEach(label => {
                if (label.parentNode) {
                    label.parentNode.removeChild(label);
                }
            });
            labels.length = 0;

            // Create new labels
            agvs.forEach(agv => {
                const label = document.createElement('div');
                label.className = 'agv-label';
                label.textContent = `${agv.id} | ${agv.state} | ${Math.round(agv.battery)}%`;
                document.body.appendChild(label);
                labels.push({ element: label, agv: agv });
            });
        }

        function updateLabelPositions() {
            const rect = renderer.domElement.getBoundingClientRect();
            labels.forEach(({ element, agv }) => {
                const vector = new THREE.Vector3(agv.currentX, 2, agv.currentZ);
                vector.project(camera);
                const x = rect.left + (vector.x * 0.5 + 0.5) * rect.width;
                const y = rect.top + (-vector.y * 0.5 + 0.5) * rect.height;
                element.style.left = x + 'px';
                element.style.top = y + 'px';
            });
        }

        // Animation loop
        function animate() {
            stats.begin();
            requestAnimationFrame(animate);

            if (!animationPaused) {
                // Update AGVs
                agvs.forEach(agv => agv.update());
            }

            // Render với Three.js
            controls.update();
            if (transformControls) {
                transformControls.update();
            }
            updateLabelPositions();
            renderer.render(scene, camera);
            
            document.getElementById('activeCount').textContent = agvs.length;
            if (typeof tickDesktopUI === 'function') tickDesktopUI();
            stats.end();
        }

        // Control functions
        function toggleAnimation() {
            animationPaused = !animationPaused;
        }
        
        function togglePaths(visible = null) {
            if (visible === null) {
                pathsVisible = !pathsVisible;
            } else {
                pathsVisible = visible;
            }
            // Ẩn/hiện paths của AGVs
            agvs.forEach(agv => {
                if (agv.pathLine) agv.pathLine.visible = pathsVisible;
                if (agv.pathMarkers) agv.pathMarkers.visible = pathsVisible;
            });
            // Ẩn/hiện standalone paths (paths không gắn với AGV)
            standalonePaths.forEach(standalonePath => {
                if (standalonePath.line) standalonePath.line.visible = pathsVisible;
                if (standalonePath.markers) standalonePath.markers.visible = pathsVisible;
                standalonePath.visible = pathsVisible;
            });
            config.showPaths = pathsVisible;
        }

        function resetCamera() {
            // Reset OrthographicCamera
            if (typeof gsap !== 'undefined') {
                Helpers.animateCamera(camera, { x: 50, y: 50, z: 50 }, 1);
                gsap.to({}, { duration: 1, onUpdate: () => {
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                }});
            } else {
                camera.position.set(50, 50, 50);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
            }
            controls.update();
        }


        // Hàm thêm AGV với path đã chọn
        function addAGVWithSelectedPath(pathIndex) {
            if (pathIndex < 0 || pathIndex >= pathDefinitions.length) {
                console.warn('Path index không hợp lệ:', pathIndex);
                return;
            }
            const path = pathDefinitions[pathIndex];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const id = `AGV-${String(agvs.length + 1).padStart(3, '0')}`;
            agvs.push(new AGV(id, path, color));
            updateLabels();
        }
        
        // Hàm cũ để tương thích (giờ sẽ dùng path đã chọn)
        function addRandomAGV() {
            // Sử dụng path đã chọn trong config, mặc định là 0
            const pathIndex = typeof config !== 'undefined' && config.selectedPathIndex !== undefined 
                ? config.selectedPathIndex 
                : 0;
            addAGVWithSelectedPath(pathIndex);
        }

        let pathsVisible = true;

        // Handle window resize (aspect theo vùng 3D để không bị cắt)
        window.addEventListener('resize', () => {
            const vs = getViewSize();
            const aspect = vs.w / Math.max(1, vs.h);
            
            if (isOrthographic) {
                const viewSize = 100;
                orthographicCamera.left = -viewSize * aspect;
                orthographicCamera.right = viewSize * aspect;
                orthographicCamera.top = viewSize;
                orthographicCamera.bottom = -viewSize;
                orthographicCamera.updateProjectionMatrix();
            } else {
                perspectiveCamera.aspect = aspect;
                perspectiveCamera.updateProjectionMatrix();
            }
            renderer.setSize(vs.w, vs.h);
        });
        
        // Keyboard shortcuts cho tạo path
        window.addEventListener('keydown', (event) => {
            if (isCreatingPath) {
                if (event.key === 'Enter' || event.keyCode === 13) {
                    event.preventDefault();
                    finishCreatingPath();
                } else if (event.key === 'Escape' || event.keyCode === 27) {
                    event.preventDefault();
                    cancelCreatingPath();
                }
            }
        });

        // Initialize labels
        updateLabels();

        // Start animation
        animate();
    </script>
</body>
</html>
